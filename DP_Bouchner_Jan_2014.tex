% options:
% thesis=B bachelor's thesis
% thesis=M master's thesis
% czech thesis in Czech language
% slovak thesis in Slovak language
% english thesis in English language
% hidelinks remove colour boxes around hyperlinks

\documentclass[thesis=M,czech]{FITthesis}[2014/05/07]

\usepackage[utf8]{inputenc} % LaTeX source encoded as UTF-8

\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}

\definecolor{lightgray}{rgb}{0.95, 0.95, 0.95}
\definecolor{darkgray}{rgb}{0.4, 0.4, 0.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\definecolor{editorGray}{rgb}{0.95, 0.95, 0.95}
\definecolor{editorOcher}{rgb}{1, 0.5, 0} % #FF7F00 -> rgb(239, 169, 0)
\definecolor{editorGreen}{rgb}{0, 0.5, 0} % #007C00 -> rgb(0, 124, 0)
\definecolor{orange}{rgb}{1,0.45,0.13}
\definecolor{olive}{rgb}{0.17,0.59,0.20}
\definecolor{brown}{rgb}{0.69,0.31,0.31}
\definecolor{purple}{rgb}{0.38,0.18,0.81}
\definecolor{lightblue}{rgb}{0.1,0.57,0.7}
\definecolor{lightred}{rgb}{1,0.4,0.5}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\usepackage{courier}
%\usepackage{acronym}
\usepackage[printonlyused,withpage]{acronym}
%\usepackage[printonlyused,withpage]{acronym} \usepackage[printonlyused,withpage]{acronym} % ukaze jen pouzite zkratky, ukaze cislo stranky, kde byla zkratka poprve pouzita
\usepackage{enumitem}
\setlist{parsep=0pt,listparindent=\parindent}
\usepackage{listings}

\lstset{backgroundcolor=\color{lightgray},
keywordstyle=\color{blue},
stringstyle=\color{mymauve},
commentstyle=\color{mygreen},
morecomment=[l][\color{magenta}]{\#},
basicstyle=\footnotesize\ttfamily,
breaklines=true
}

\usepackage{graphicx} %graphics files inclusion
% \usepackage{amsmath} %advanced maths
% \usepackage{amssymb} %additional math symbols

\usepackage{dirtree} %directory tree visualisation

\usepackage{nameref}

\usepackage{epigraph}
\setlength{\epigraphrule}{0pt}
\setlength{\epigraphwidth}{.95\textwidth}

% % list of acronyms
% \usepackage[acronym,nonumberlist,toc,numberedsection=autolabel]{glossaries}
% \iflanguage{czech}{\renewcommand*{\acronymname}{Seznam pou{\v z}it{\' y}ch zkratek}}{}
% \makeglossaries

\newcommand{\tg}{\mathop{\mathrm{tg}}} %cesky tangens
\newcommand{\cotg}{\mathop{\mathrm{cotg}}} %cesky cotangens

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% ODTUD DAL VSE ZMENTE
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\department{Katedra softwarového inženýrství}
\title{Adaptibilní systém pro doporučování obsahu}
\authorGN{Jan} %(křestní) jméno (jména) autora
\authorFN{Bouchner} %příjmení autora
\authorWithDegrees{Bc. Jan Bouchner} %jméno autora včetně současných akademických titulů
\supervisor{Ing. Jaroslav Kuchař}
\acknowledgements{Chci upřímně poděkovat všem, kteří mi věnovali čas, když jsem potřeboval pomoc při psaní této diplomové práce, především vedoucímu práce Ing. Jaroslavu Kuchaři za správné směrování, celkový vhled do technologií a cenné komentáře. Děkuji také své rodině a všem přátelům za bezvýhradnou podporu během celých mých studií.}
\abstractCS{V~několika větách shrňte obsah a přínos této práce v~češtině. Po přečtení abstraktu by se čtenář měl mít čtenář dost informací pro rozhodnutí, zda chce Vaši práci číst.}
\abstractEN{Sem doplňte ekvivalent abstraktu Vaší práce v~angličtině.}
\placeForDeclarationOfAuthenticity{V~Praze}
\declarationOfAuthenticityOption{4} %volba Prohlášení (číslo 1-6)
\keywordsCS{Nahraďte seznamem klíčových slov v češtině oddělených čárkou.}
\keywordsEN{Nahraďte seznamem klíčových slov v angličtině oddělených čárkou.}

\begin{document}

% \newacronym{CVUT}{{\v C}VUT}{{\v C}esk{\' e} vysok{\' e} u{\v c}en{\' i} technick{\' e} v Praze}
% \newacronym{FIT}{FIT}{Fakulta informa{\v c}n{\' i}ch technologi{\' i}}

\begin{introduction}
	%sem napište úvod Vaší práce	
\begin{epigraphs}
\qitem{We are leaving the age of information and entering the age of recommendation.}%
 {---\textsc{Chris Anderson, 2004}}
 \end{epigraphs}	
	Hned na úvod práce jsem si dovolil použít citát z článku \emph{The Long Tail}~\cite{anderson} bývalého šéfredaktora časopisu Wired Chrise Andersona, který je též autorem stejnojmenné teorie. Ta je založena na tom, že díky rozvoji internetu lze dnes nabízet daleko širší paletu produktů než bylo možné dříve.
	
	Před nástupem digitálního věku spoléhali lidé při svých nákupech spíše na obecnou oblíbenost daného produktu, než na vlastní úsudek. Oblíbenost byla přitom více než cokoliv jiného určována aktuálním společenským trendem či preferencemi známých.	

	S masovým rozvojem internetu začalo růst množství dostupných informací obřím tempem (organizace IDC došla v článku~\emph{Extracting Value from Chaos} k závěru, že objem světových dat se každé dva roky zdvojnásobuje~\cite{digitaluniverse}), nové informace jsou produkovány takřka každou sekundu a na jejich setřídění máme čím dál tím méně času.
	
	Takovýmto vývojem se přirozeně změnil i lidský přístup ke zpracování informací. Naším cílem již není nashromáždit jich co nejvíce – tímto pokusem bychom se zanedlouho dostali do stavu informačního zahlcení. Ceněným uměním je naopak schopnost vytěžit maximum užitečných informací a ty využít k nabytí nových vědomostí.
	
	Úvahy v předchozích odstavcích směřují k již zmíněné teorii The Long Tail. S nárůstem dostupných informací dochází ke snižování prodeje produktů, které dříve určoval trend, ve prospěch produktů nacházejících se v takzvaném dlouhém chvostu. V nikterak závratné míře, přesto se jedná o jisté procento (pravidlo je uváděno jako 80/20~\cite{longtail2}). 
	
	Tento fenomén lze dost dobře ilustrovat na příkladu hudebního průmyslu. Díky obrovským databázím\footnote{Servery jako Spotify, last.fm, Grooveshark, Google Music a řada dalších.} hudebních interpretů a skladeb již nedochází k selekci a prodeji či poslechu zlomku těch potenciálně nejúspěšnějších. Uživatelé jsou konfrontování s mnohem širším výběrem a je pouze na nich, kterého interpreta či skladbu si k poslechu zvolí.		

\section{Doporučování obsahu}
\label{sub:recsys}
	Všechny výše zmiňované faktory přirozeným způsobem zapříčinily rozvoj přístupu zvaného jako \emph{informační filtrování}. Tím je myšlena selekce a redukce informací (na základě jistých volených parametrů). Odtud už je pak jen krok k doporučování obsahu uživateli na míru, které se v posledních několika letech rozmáhá se zaváděním tzv. \emph{doporučovacích systémů}.

Doporučování lze dělit do dvou skupin dle způsobu vykonávané práce. 

\begin{description}
	\item[Kolaborativní filtrování] Doporučení z této skupiny nejčastěji využívají stránky zabývající se prodejem různých produktů.
	
	\item[Doporučení založená na obsahu] Druhou skupinou jsou doporučení založená na obsahu, nejčastěji na textové podobnosti.
\end{description}

	Vývoj v oblasti informačních věd je však rychlý. V dnešní době již není zárukou, že server s aktuálními novinkami ze světa, který za účelem zvýšení čtenosti svých článků nasadí některé z nabízených doporučení do architektury svého systému, dosáhne tímto krokem výrazného zlepšení.
	
	Roste potřeba systémů kombinujících více doporučovacích metod, které jsou schopny přizpůsobit se svým uživatelům na míru a pružně reagovat na neustále se měnící preference v průběhu času. 

\section{Motivace} 	
\label{sec:motivation}

	Představme si nyní takový systém jako rádce, který je v každém okamžiku schopen rozhodnout, co je pro uživatele za daných okolností nejvhodnější.
	
	To, o čem rádce rozhoduje, je volba algoritmu, jakým si má uživatel nechat v danou chvíli doporučit obsah. Pokud by uživatel dbal rádcových rad, pak by s největší pravděpodobností obdržel vhodné doporučení a svou spokojenost by vyjádřil například tím, že by u jedné z doporučených položek zažádal o bližší detaily, případně ji ohodnotil na škále od jedné do pěti.
	
	Rádce sám neprovádí žádné operace, dokud k nim není explicitně vyzván uživatelem.
	
	Jeho silnou stránkou je to, že díky průběžné analýze a neustálému přepočítávání možností dokáže pružně reagovat na situace, kdy dojde k náhlé a hromadnější změně preferencí nebo vyvstanou jiné neočekávané události, jež by měly za následek dlouhodobější doporučování nevhodného obsahu.
	
\section{Cíle práce}
\label{sec:objectives}
	Cílem je vyvinout aplikaci s podobnými znaky chování, jaké vykazuje rádce výše.

	Nejdůležitějším cílem této práce je tedy návrh a implementace adaptibilního systému, který by byl schopen automaticky a vhodně kombinovat metody pro doporučování obsahu. Metodami jsou zde zamýšleny algoritmy. Výběr vhodné sady algoritmů je též jedna ze součástí této práce.
	
	Dále bude systém zpracovávat zpětnou vazbu od uživatelů týkající se kvality zvoleného doporučení, která principem odměny za dobré doporučení nebo trestu za špatné ovlivní preference při kombinování.
	
	Systém bude též zodpovědný za poskytování podpory většímu množství uživatelů zasílajících žádosti na systém.
	
	Nezbytnou součástí diplomové práce je osvojení základních pojmů a pravidel z oblasti strojového učení, teorie pravděpodobnosti a statistiky užívaných zejména v části práce týkající se predikce vhodného algoritmu a dopadu zpětné vazby. 
	
	Vzhledem k povaze projektu bude nutné navrhnout obecné rozhraní jak pro manipulaci s doporučovacími algoritmy, tak pro tento adaptibilní systém.
	
	Funkčnost navrženého systému bude ověřena implementací prototypu a jeho spuštěním na modelové úloze.
	
	K dosažení těchto cílů bude zapotřebí vyvinout následující části:

\begin{itemize}
  \item \textbf{Adaptibilní systém pro doporučování obsahu.}
  \item \textbf{Sada základních algoritmů určených k doporučování.}
  \item \textbf{RESTful API pro manipulaci s doporučovacími algoritmy a systémem.}
\end{itemize}	

\section{Struktura práce}
\label{sec:structure}
	Tato práce je strukturována do pěti různých kapitol. Kapitoly jsou řazeny v pořadí, v jakém probíhaly jednotlivé fáze vývoje.	

\begin{description}
  \item[Kapitola \nameref{chap:current}] Popisuje historické pozadí i trendy používané současnými doporučovacími systémy. Snahou této rešerše je vyvodit závěry, jež by mohly být užitečné pro náplň dalších kapitol.
  \item[Kapitola \nameref{chap:analysis}] Shromažďuje veškeré požadavky kladené na systém, dále se zabývá návrhem architektury, detailními návrhy serverové i klientské části, rozhraním zastřešujícím komunikaci těchto částí a výběrem základní sady algoritmů, které budou využity k doporučování obsahu. 
  \item[Kapitola \nameref{chap:adapt}] Detailně popisuje algoritmické a matematické postupy použité při návrhu adaptibilního systému. 
  \item[Kapitola \nameref{chap:impl}] Popisuje vývoj aplikace na základě provedené analýzy a návrhu.
  \item[Kapitola \nameref{chap:tests}] Shrnuje poznatky nabyté z provedených experimentů se systémem a hodnotí vyvinutou aplikaci. 
\end{description}
	
\end{introduction}

\chapter{Teoretická část}		


\section{Aktuální stav na poli doporučování}	
\label{chap:current}

V dnešní moderní době je možné setkat se s celou řadou různých doporučení, např.: 

\begin{itemize}
	\item Lidé, které byste mohli znát.
	\item Uživatelé kupující produkt X kupují též produkt Y.
	\item Položky, které jsou podobné položce XY	.
\end{itemize}

Jak vidno, doporučení nesou různá označení, všechny však sdílejí stejnou myšlenku – zaujmout či upozornit na něco či někoho konkrétního. Spousta elektronických obchodů, renomovaných aukčních domů, ale též serverů se zábavou na nich doslova staví své podnikání, neboť správně navržený a fungující doporučovací systém může přinést výrazné navýšení zisku. 

Sami firemní zákazníci navíc o doporučení stojí. Usnadňují jim navigaci po stránce a existuje zde vysoká šance, že na jejich základě přizpůsobí své chování.

Důvěra uživatele v navštívenou stránku je nicméně tak velká, jak dobrá doporučení stránka poskytuje. Pokud zákazník dostává samá špatná doporučení, nenásleduje je a ve výsledku odmítá celý systém.

\subsection{Analýza vybraných systémů}
\label{sec:examples}
Na internetu lze narazit na desítky, ba i stovky systémů zapojených do reálného provozu. Záměrně jsem se snažil vybral pouze zlomek, jenž by ale zároveň pokrýval většinu typů doporučovaného obsahu (produkty, články, zábava apod.).

U těchto systémů jsem se snažil identifikovat, jaké postupy jsou prováděny na pozadí jejich doporučování, jaké k tomu využívají metody a vzhledem k povaze řešeného problému jsem zkoumal též znaky týkající se kombinování metod, kterými bych se mohl nechat inspirovat při návrhu svého systému.

\subsubsection{Amazon.com}

\textbf{Amazon.com, Inc.}\footnote{\url{http://www.amazon.com}} je jedním z největších a nejstarších internetových prodejců. Společnost začínala jako online knihkupectví, postupem let však zařadila do své prodejní nabídky též hudební a filmové nosiče, software, elektroniku, nábytek a spoustu dalšího zboží včetně vlastní spotřební elektroniky v podobě čtečky elektronických knih a tabletů Kindle či poskytování služeb z oblasti cloud computingu.

Firmu lze řadit mezi průkopníky doporučování na internetu. Jako jeden z prvních internetových prodejců začala svým zákazníkům doporučovat výrobky na základě nákupů jiných uživatelů.

Doporučovací systém společnosti je založen na více zdrojích informací:

\begin{itemize}
	\item porovnávání uživatelem prohlížených položek a položek umístěných uvnitř nákupního košíku s položkami, které se společně s těmito prohlíženými položkami v minulosti často prodávaly\footnote{affinity analysis – nacházení spojení mezi odlišnými položkami. Základním příkladem budiž vztah mezi šamponem a kondicionérem. Kupující je většinou používá v ten samý čas~\cite{affinity}. Při nákupu jednoho by mohl mít tedy zájem i o druhý.}.
	\item uchovávání informací ohledně hodnocení položek uživateli
	\item zaznamenávání nákupní historie (Pokud uživatel v minulém měsíci zakoupil tři dětské knížky, znamená to, že má dítě?)
	\item sledování spousty dalších postupů, jako například vyhodnocování demografických informací (dle doručovací adresy), zaznamenávání pohybu po stránce (jaké všechny položky si uživatel prohlédl, než vložil jednu konkrétní do nákupního košíku) nebo sledování prokliků\footnote{Jako proklik se označuje takové kliknutí na odkaz, které uživatele dovede na cílovou stránku~\cite{proklik}.} z marketingových e-mailů s odkazy na zboží~\cite{amazonrec}.
\end{itemize}

Společnost užívá jako svou hlavní doporučovací strategii \emph{item-to-item kolaborativní filtrování}. Fanoušek moderních technologií tak může při návštěvě stránek nalézt odkazy na technologické novinky všeho druhu, zatímco mladá matka bude mít v nabídce té samé stránky ve větší míře zastoupeno dětské zboží.
 
Výše jsou samozřejmě popsány pouze základní principy. Doporučovací systém společnosti jako takový je velmi komplexní a detaily algoritmu jsou drženy jako obchodní tajemství. K nahlédnutí jsou ale patenty, např. \emph{Personalized recommendations of items represented within a database}~\cite{jacobi2006personalized} nebo \emph{Collaborative recommendations using item-to-item similarity mappings}~\cite{linden2001collaborative}.

\subsubsection{Netflix}

\textbf{Netflix, Inc.}\footnote{\url{https://www.netflix.com}} je společnost, poskytující v začátcích své služby jako internetová videopůjčovna, jež se v průběhu posledních několika let rozrostla v obrovskou mediální společnost. Strategicky významným byl pro ni rok 2007. Tehdy byla nabídka jejích služeb rozšířena o filmy přenášené přes stream\footnote{Snímek se fyzicky nenachází na koncovém zařízení, ale přehrává se přímo ze serveru poskytovatele .}~\cite{netflix2007}. Nyní společnost nabízí obsah v podobě filmů a seriálů pro většinu v dnešní době používaných platforem jako PC, Mac, PlayStation3, Wii, Xbox a také pro mobilní telefony a tablety. 

Vzhledem k tomu, že firma staví své podnikání na tom, že její zákazníci ji platí za konzumaci zábavy, je v jejím vlastním zájmu, aby těmto uživatelům sledujícím filmy a seriály nabízela automaticky další obsahově či žánrově podobné, zkrátka takové, jenž budou co možná nejvíce lahodit jejich vkusu (dle~\cite{netflixrec} pochází $\frac{2}{3}$ zapůjčených filmů na Netflix z předchozího doporučení). Úspěšné podnikání společnosti je tak přímo závislé na tom, jak kvalitním doporučovacím systém společnost disponuje. 

\begin{description}
	\item[Netflix Prize]

\cite{netflixrules} Za tímto účelem vyvinula společnost vlastní systém \emph{Cinematch} napomáhající svým zákazníkům objevit pro ně zajímavé filmy. Postupný vývoj na poli doporučovacích systémů však přivedl společnost na otázku, zda není možné vyvinout systém, jenž by dokázal Cinematch v oblasti předpovídání filmového vkusu porazit.Společnost tak vypsala začátkem října 2006 soutěž známou jako \emph{Netflix Prize}. Týmu, kterému by se podařilo zlepšit dosavadní výsledky systému Cinematch alespoň o 10 procent, by byla přiřknuta odměna ve výši 1 milion amerických dolarů.

Do soutěže byla uvolněna sada testovacích dat obsahující:

\begin{itemize}
	\item ID uživatele
	\item ID filmu
	\item hodnocení na intervalu $\langle1,5\rangle$
	\item datum uskutečnění hodnocení
\end{itemize}

Data obsahovala 100 480 507 takových hodnocení pro 17 770 filmů od 480 189 uživatelů. Uvolněna byla ještě další sada testovacích dat obsahující stejné informace, jen s vynecháním uživatelských hodnocení. Cílem pak bylo predikovat tato chybějící hodnocení opět na intervalu $\langle1,5\rangle$.

Celková výhra byla udělena až v roce 2009 (do té doby sice docházelo k průběžnému zlepšování výsledků, nikdy však nebylo dosaženo požadovaného zlepšení 10 procent) týmu \emph{BellKor's Pragmatic Chaos}, vzniklého spojením tří do té doby samostatně soutěžících týmů.

Vítězný tým dosáhl cíle pomocí \emph{pokročilých technik strojového učení}. Zjistil přitom především to, že hodnocení každého filmu je silně subjektivní záležitostí, kterou je velmi obtížné programově předpovědět. Ukázalo se také, že ve větší míře záleží na tom, zda uživatel hodnotí právě dosledovaný film nebo film, který zhlédl již před delší dobou. Velkou roli hraje i nálada uživatele v průběhu dne a další faktory~\cite{bellkor}.

Výsledný algoritmus, jenž získal cenu, vznikl kombinováním zhruba stovky menších algoritmů. S trochou nadsázky lze tedy prohlásit, že jednou z hlavních taktik pro kvalitní doporučení je \emph{použití tolika algoritmů, kolik je jen možné}.
	
	
\end{description}

\subsubsection{Mendeley}	
\label{mendeley}
\textbf{Mendeley}\footnote{\url{http://www.mendeley.com}} je systém určený k doporučování vědeckých článků využívající jako svou výpočetní vrstvu technologii Apache Mahout\footnote{https://mahout.apache.org}. Cílem systému je spojovat dohromady výzkumníky a jejich data. Svým uživatelům napomáhá v organizaci výzkumu, umožňuje jim navázat potenciální spolupráci s dalšími uživateli aplikace a napomáhá též k objevení nových podnětů pro vlastní práci. Uživateli této aplikace jsou přední světové university jako University of Cambridge, Stanford University, MIT či University of Michigan. Data pro aplikaci pocházejí z vlastních importů uživateli i z externích importů skrze různé katalogy vědeckých prací. 

Projekt samotný se v jedné ze svých prezentací~\cite{mendeleylastfm} přirovnává k největší hudební databázi na internetu – last.fm\footnote{http://www.last.fm}. Ta funguje na principu, že potenciální uživatel provede na svém počítači instalaci desktopové aplikace, následně s již instalovanou aplikací začne poslouchat hudbu a tím je zahájeno automatické odesílání informace o skladbě (interpret, žánr) na server last.fm. Podle dat odeslaných na server jsou uživateli v budoucnu doporučovány další skladby. 

Mendeley tuto analogii vysvětluje tak, že hudební knihovny jsou v jeho případě výzkumné knihovny, role interpretů zastávají jednotliví výzkumníci, hudební skladby jsou pak jimi publikované články a jednotlivé hudební žánry reprezentují vědecké disciplíny.  

Doporučení jsou dle dostupných informací~\cite{mendeleylastfm} generována dvojím způsobem. 

\begin{description}
	\item[Kolaborativní filtrování] Používá se pro personalizované doporučení. Podporována je jak user-based, tak item-based varianta.
	\item[Filtrování založené na obsahu] Používá se k nalezení souvisejících výzkumů, například pro nalezení článku ze stejné výzkumné kategorie nebo článku majícího podobný název. 
\end{description}

Uživatelé vyjadřují svůj zájem či nezájem o každou z doporučených položek zpětnou vazbou, která je dvojího typu:

\begin{description}
	\item[Accept] vyjadřuje, že uživatel s daným doporučením souhlasí nebo pro něj bylo nějakým způsobem užitečné.
	\item[Remove] vyjadřuje nevhodné doporučení. Uživatel touto volbou dává najevo, že podobné doporučení by příště již raději nedostal.
\end{description}

\subsubsection{Google News}	

Vlastní platformu pro doporučování obsahu vytvořila v rámci svého vývoje též společnost \textbf{Google, Inc.}~\footnote{\url{http://www.google.com/about/company}}. Její výzkumníci se v práci~\cite{googlenews} zabývali vývojem prediktivního systému pro personalizované doporučování zpráv na webu Google News~\footnote{\url{http://news.google.com}}.

Přihlášeným uživatelům, majících v prohlížeči explicitně povolen záznam historie prohlížení, jsou generována doporučení založená na zájmu těchto uživatelů, která vycházejí z různých profilů sestavených pozorováním chování uživatelů na stránce.  

K porozumění, jak se mění zájem uživatelů o zprávy v čase, napomohla výzkumníkům analýza logů (záznamy chování anonymních uživatelů na stránce). Na základě této analýzy byl vyvinut Bayesovský framework pro předvídání zájmu uživatelů o zveřejňované novinky.

Kombinace mechanismu pro filtraci informací vzešlého z nashromážděných uživatelských profilů a již existujícího mechanismu využívajícího principů kolaborativního filtrování vedla ke vzniku systému generujícího personalisovanou nabídku zpráv. Vzniklá kombinace byla nasazena do reálného provozu a následné experimenty prokázaly, že kombinováním metod došlo ke zlepšení kvality doporučování.

\subsubsection{Výzkum}

Také současný výzkum v oblasti doporučovacích systémů, zdá se, nezahálí. Zde uvádím příklad dvou populárních akcí, jejichž náplní či součástí je problematika doporučování a doporučovacích systémů.

\begin{itemize}
  \item \textbf{ACM RecSys conference.}~\footnote{\url{http://recsys.acm.org}} Konference je předním mezinárodním fórem pro prezentaci nových výsledků výzkumu a postupů na poli doporučovacích systémů. RecSys sdružuje hlavní mezinárodní výzkumné skupiny a též mnoho předních světových společností na trhu e-commerce. Nabízí také doprovodný program v podobě zvaných přednášek, konzultace týkající se problematiky RecSys a sympózium studentů doktorských programů. 
  
  Zajímavé prezentace jsou volně dostupné na internetu, dá se tedy načerpat spousta inspirace do vlastního výzkumu. Mě osobně velmi zaujala prezentace~\footnote{\url{http://www.slideshare.net/d0nut/open-recommendation-platform}} z posledního ročníku konference (Hong Kong, 2013), se kterou vystoupil Torben Brodt, jeden z klíčových řečníků. V prezentaci popisuje tzv. \emph{Open Recommendation Platform}~\ref{sub:orp}. 
  
  \item \textbf{ICWSM: Weblog and Social Media.}~\footnote{\url{http://www.icwsm.org/2014}} The International AAAI Conference on Weblogs and Social Media je mezinárodní konference, na které se střetávají výzkumní pracovníci z oblasti počítačových a společenských věd. Konference je pořádaná za účelem sdílení znalostí, diskutování o nápadech a výměny informací. Probíranými body jsou psychologické a sociální teorie, výpočetní algoritmy pro analýzu sociálních médií a jedním z mnoha témat jsou též doporučovací systémy.
\end{itemize}

O tématu se též píše spousta článků a každým rokem vzniká několik disertačních prací. Dle dostupných informací z ACM RecSys Wiki~\footnote{\url{http://www.recsyswiki.com/wiki/List_of_recommender_system_dissertations}} jich jen za poslední 4 roky bylo přes 50.

\subsubsection{Open Recommendation Platform}
\label{sub:orp}
\textbf{Open recommendation Platorm} (zkr. ORP) je projekt společnosti \textbf{plista}\footnote{\url{https://www.plista.com}} prezentovaný na posledním ročníku konference ACM RecSys 2013 v Hong Kongu. 

Motivací ORP bylo dosáhnout lepších výsledků kombinací více metod doporučování obsahu společně se zapojením kontextu uživatele (informacemi čerpanými převážně z HTTP hlaviček). Takovými informacemi mohou být například:

\begin{itemize}
	\item IP adresa, která může prozradit geologickou lokaci uživatele,
	\item denní doba, kdy uživatel přistupuje ke stránce,
	\item user agent prohlížeče informující o zařízení, ze kterého bylo k obsahu přistoupeno (mobilní telefon, PC),
	\item referer pro zjištění způsobu přístupu (přístup z vyhledávání nebo přímý přístup). 
\end{itemize}

Abstraktní pohled na ORP znázorňuje obrázek~\ref{fig:plista}, na kterém je systém zachycen jako \emph{Ensemble}. Ensemble je schopen dle uživatelských preferencí vybírat z kolekce doporučovacích algoritmů ten nejvhodnější, jenž pak použije k publikování obsahu pro daného uživatele. Konzumenti obsahu (\emph{Visitors}) poté zasílají systému zpětnou vazbu, díky které dochází k rekalkulaci preferencí, což ovlivní výběr nejlepšího algoritmu pro další doporučení.

\begin{figure}\centering
	\includegraphics[width=1.0\textwidth]{obr/plistaEnsemble.png}
 	\caption[Abstraktní pohled na systém společnosti plista]{Abstraktní pohled na systém společnosti plista. Zdroj: \cite{slideshare:plista}}\label{fig:plista}
\end{figure}	

V prezentaci bylo zmíněno několik užitečných rad ohledně toho, co všechno by měl systém podobného typu umět. Zmíněna je potřeba rychlého webového serveru, na kterém bude aplikace běžet, dále nutnost rychlého síťového protokolu a rychlé fronty zpráv. Padla zde též potřeba rychlého úložiště pro data.

K dosažení správné funkcionality pro výběr nejlepšího algoritmu společnost používá tzv. \emph{multi-armed bayesian bandit}~\ref{sub:mabandit} v bayesovské variantě, což je i jedna ze strategií, kterou mi na úvodní schůzce doporučil vedoucí této práce.

\subsubsection{easyrec}
Technická knihovna společnosti IBM obsahuje přehledný seznam~\cite{ibm} několika doporučovacích systémů, z nichž převážná část vznikla jakou součást univerzitního výzkumu.

Z tohoto seznamu se mi jako velmi zajímavý jeví systém \textbf{easyrec}\footnote{\url{http://easyrec.org/recommendation-engine}}. Jedná se o open source webovou aplikaci napsanou v programovacím jazyce Java nabízející personalizovaná doporučení prostřednictvím RESTful webových služeb. Díky vystavenému REST API\footnote{REST API systému easyrec: \url{http://easyrec.org/implement}} je vývojáři umožněno napojit svou aplikaci psanou v libovolném jazyce na systém a využívat jejích funkcionalit. Lze tak zasílat uživatelské akce typu prohlížení, provedení nákupu či hodnocení položky a žádat o doporučení. Tyto uživatelské akce jsou ukládány do databáze easyrec.

K doporučování lze přistupovat prostřednictvím specifických endpointů, například \emph{zboží související s danou položkou}, dále \emph{ostatní uživatelé prohlíželi též tyto položky} nebo lze dostávat \emph{specifická doporučení pro daného uživatele}~\cite{ibm}. 

Systém provádí na pozadí analytické operace, obsahuje též databázi asociačních pravidel a podporu online i offline doporučování. Uživatelským aplikacím připojujícím se k systému generuje v odpovědích žádaná doporučení (viz obrázek~\ref{fig:easyrec}).

\begin{figure}\centering
	\includegraphics[width=1.0\textwidth]{obr/easyrec.png}
 	\caption[Abstraktní model open source systému easyrec]{Abstraktní model open source systému easyrec. Zdroj: \cite{easyrec}}\label{fig:easyrec}
\end{figure}	

\subsection{Shrnutí poznatků z analýzy}  

   \begin{table}
   \centering
\begin{tabular}{|c|c|}
        \hline \bfseries Systém & \bfseries Vlastnosti \\ \hline
    \hline
  \bfseries Amazon.com & 
  \begin{minipage}{3.5in}
    \vskip 6pt
    \begin{enumerate}
   \item Kolaborativní filtrování užívající podobnostní mapování item-to-item~\cite{linden2001collaborative}.
   \item Personalizovaná doporučování získávaná asociačními pravidly z databáze informací o uživatelích~\cite{jacobi2006personalized}.
   \end{enumerate}
   \vskip 6pt
 \end{minipage}
 \\
  \hline
  
  \bfseries Netflix & 
  \begin{minipage}{3.5in}
    \vskip 6pt
    \begin{enumerate}
   \item Predikce uživatelských hodnocení založená na technikách strojového učení~\ref{sec:machine}.
   \item Pro doporučování je využíváno více jednotlivých algoritmů a jejich kombinování.
   \end{enumerate}
   \vskip 6pt
 \end{minipage}
 \\
  \hline  
  
  \bfseries Mendeley & 
  \begin{minipage}{3.5in}
    \vskip 6pt
    \begin{enumerate}
   \item Doporučení založená na kolaborativním filtrování ve variantách user-based i item-based.
   \item Doporučení založená na podobnosti obsahu (podobnost článků, nadpisů, klíčových slov apod.)
   \item Důraz na pozitivní a negativní zpětnou vazbu. Negativní zpětná vazba sníží pravděpodobnost budoucího doporučení podobné položky, pozitivní naopak upřesní budoucí doporučované položky.
   \item Výpočetní vrstva pro doporučování postavená nad Apache Mahout~\ref{mahout}. 
   \end{enumerate}
   \vskip 6pt
 \end{minipage}
 \\
  \hline    
  
  \bfseries Google News & 
  \begin{minipage}{3.5in}
    \vskip 6pt
    \begin{enumerate}
   \item Kombinování informací získaných z předchozího chování na stránce a technik kolaborativního filtrování.
   \end{enumerate}
   \vskip 6pt
 \end{minipage}
 \\
  \hline   
  
  \bfseries ORP & 
  \begin{minipage}{3.5in}
    \vskip 6pt
    \begin{enumerate}
   \item Kombinování více doporučovacích metod společně s kontextem uživatele.
   \item Přítomnost mezivrstvy v podobě rádce starajícího se o obsluhu uživatelů a jejich doporučení.
   \item Silný důraz na zpětnou vazbu a následné přepočítávání budoucích šancí doporučení.
   \item Ke kombinaci je využíváno strategie Multi-armed bandit~\ref{sec:multi} v bayesovské variantě~\ref{bayes}.
   \end{enumerate}
   \vskip 6pt
 \end{minipage}
 \\
  \hline     
  
  \bfseries easyrec & 
  \begin{minipage}{3.5in}
    \vskip 6pt
    \begin{enumerate}
   \item Veškeré uživatelské akce (provedení akce, zpětná vazba, žádost o doporučení konkrétním algoritmem) s doporučovacím systémem probíhají skrze komunikaci s RESTful API.
   \end{enumerate}
   \vskip 6pt
 \end{minipage}
 \\
  \hline    
 \end{tabular}
     \caption {Shrnutí poznatků o jednotlivých systémech vyplývající z provedené analýzy.}
     \label{tab:table}
   \end{table} 

Z výše uvedených příkladů v sekci~\ref{sec:examples} lze vypozorovat určité vlastnosti (shrnutí v tabulce~\ref{tab:table}) a zformulovat několik závěrů:

\begin{itemize}
	\item O uživateli je vedena spousta záznamů, především historie jeho chování na stránkách.
	\item Velký důraz je kladen na zpětnou vazbu (vyjádření zájmu uživatele o doporučený obsah), ať už formou přečtení článku, ohodnocení položky apod.
	\item Stále je využíváno osvědčených metod kolaborativního filtrování a filtrování na základě obsahu.
	\item Síla není v použití jednoho konkrétního algoritmu, ale v kombinaci více metod a přístupů dohromady.
	\item Většina systémových výpočtů běží na pozadí v tom samém čase, co uživatel tráví prohlížením stránky. Systém je schopna rychle se přizpůsobit okolnostem.
	\item Problematika kombinování metod má silnou závislost na strojovém učení a teorii pravděpodobnosti a statistiky (především bayesovské).
	\item Realizace RESTful API je poměrně vhodný způsob komunikace s doporučovacím systémem ověřeným v praxi.
\end{itemize}

Existujících řešení je tedy celá řada. Každé z těchto řešení je přitom využíváno k vlastnímu účelu a není snadno přenositelné.

Jisté je navíc to, že době, kdy obchodníkům stačilo na svůj elektronický obchod nasadit jednoduchý algoritmus kolaborativního filtrování, odzvonilo a budoucnost patří systémům schopným nějaké predikce a přizpůsobení svého vývoje, a to vše v reálném čase. 

\section{Adaptibilní systém}
\label{chap:adapt}

\subsection{Minimální teoretický základ}

Ještě předtím, než se pustím do popisu strategie, zopakuji zde některé pojmy týkající se strojového učení, teorie pravděpodobnosti a statistiky. Jedná se o minimální základ potřebný k pochopení postupů popisovaných dále v této sekci. 

\subsubsection{Strojové učení}
Strojové učení je vědecká disciplína (jedna z větví oboru umělé inteligence), jež se zabývá tím, jak se má počítač přizpůsobit určité situaci, aniž by byl pro danou situaci explicitně naprogramován. Detailněji v sekci~\ref{sec:machine}.

\subsubsection{Agent}
\label{agent}
Agent je speciální autonomní program, který jedná samostatně a nezávisle bez vedení uživatele. Jeho úkolem je komunikovat s okolím a interagovat v závislosti na okolních podnětech. Dalšími důležitými vlastnostmi jsou schopnost příhodně reagovat na danou situaci a též proaktivně vykonávat činnost a dosahovat cíle prostřednictvím vlastní iniciativy. Jedná se o definici obecnou, ale pro naše potřeby zcela dostačující.

Problematika agentů a agentních systémů je jinak samostatný obor spadající do oblasti umělé inteligence a jeho zkoumání by vydalo na další závěrečnou práci. 

\subsubsection{Zpětná vazba}
Zpětnou vazbou je označován proces, ve kterém na základě obdržených informací (například při komunikaci s nějakým systémem) a reakcí na ně ovlivňujeme jejich budoucí podobu – část systémového výstupu lze tedy použít jako vstup pro další činnost systému.

Rozlišujeme dva typy reakcí, a to kladnou zpětnou vazbu a zápornou zpětnou vazbu. Téma má blízko k psychologickému zkoumání toho, jakým způsobem dokáže ovlivnit zapojení odměny a trestu lidské chování.

\subsubsection{Základy teorie pravděpodobnosti}

Nejprve uvedu několik pojmů z teorie pravděpodobnosti, se kterými budu v následujícím textu pracovat.

\begin{description}
	\item[Pravděpodobnostní prostor] prováděného náhodného pokusu je tvořen trojicí $(\Omega,\mathcal{F},P)$, kde:
	\begin{itemize}
		\item $\Omega$ je prostor elementárních jevů (např. čísla od jedné do šesti na šestistranné hrací kostce), kde elementárním jevem nazýváme libovolný možný výsledek $\omega \in \Omega$ 
		\item $\mathcal{F}$ je množina náhodných jevů (potenční množina\footnote{Potenční množina množiny $X$ je množina obsahující všechny podmnožiny množiny $X$} množiny $\Omega$)
		\item $P$ je přiřazení pravděpodobnosti jednotlivým jevům z $\Omega$ ($P(\Omega)=1$)
	\end{itemize}
\end{description}

\begin{description}
	\item[Náhodný jev]
	
Náhodný jev $A$ výsledek náhodného pokusu. Příkladem jevu může být například hod mincí a pozorování, zda padla panna nebo orel. V tomto jevovém prostoru jsou zahrnuty celkem dva elementární jevy (hodnota panna a hodnota orel), které souvisejí s pokusem (pozorování výskytu elementárních jevů během házení).	
\end{description}

\begin{description}
	\item[Náhodná veličina]
	\label{randomvel}
Výsledkem náhodného pokusu nemusí být číslo (v příkladu výše jsme měli dvě hodnoty po stranách mince), proto je vhodné těmto výsledkům kvůli matematickému zpracování čísla přiřazovat. Způsob přiřazení čísla výsledku náhodného pokusu se označuje jako \emph{náhodná veličina $X$}~\cite{pst1}. Pro počítání padlých panen při opakovaném házení mincí by mohlo přiřazení vypadat například takto:

\begin{itemize}
	\item $X(panna) = 1$
	\item $X(orel) = 0$
\end{itemize}

Náhodná veličina na pravděpodobnostním prostoru $(\Omega,\mathcal{F},P)$ je tedy funkce $X: \Omega \to R$, která každému $\omega \in \Omega$ přiřadí $X(\omega)$ a pro kterou platí podmínka měřitelnosti:

\begin{center}
$\{ X \leq x \} = \{ \omega \in \Omega: X(\omega) \leq x \} \in \mathcal{F}, \forall x \in R$
\end{center}

Dle typu se rozlišují náhodné veličiny diskrétní a spojité. Diskrétní náhodné veličiny mohou nabývat pouze konečného počtu hodnot z $R$ (například ročník studia), zatímco spojité náhodné veličiny nabývají v určitém intervalu libovolné reálné hodnoty (například čas potřebný k dokončení diplomové práce). 

Pravděpodobnostní rozdělení náhodné veličiny určuje její distribuční funkce. 
\end{description}	

\subsubsection{Distribuční funkce}
\label{cdf}
Distribuční funkce náhodné veličiny $X$ je funkce $F: R \to \langle0,1\rangle$ definovaná vztahem 

\begin{center}
$F(x) = P(X \leq x) = P(\{ \omega \in \Omega: X(\omega) \leq x \})$.
\end{center}

Vyjadřuje tedy pravděpodobnost, že hodnota náhodné veličiny $X$ nabude hodnoty menší nebo rovné zadané hodnotě (libovolnému $x \in R$). Distribuční funkce určuje rozdělení pravděpodobnosti.

\subsubsection{Kvantilová funkce}
\label{icdf}
\cite{pst2} Podobně jako distribuční funkce, i kvantilová funkce se týká rozdělení pravděpodobnosti. Lze ji považovat za funkci inverzní k distribuční funkci, neboť zatímco distribuční funkce $y = F(x)$ vyjadřuje pravděpodobnost, s jakou bude hodnota náhodné veličiny $X$ menší nebo rovna $x \in R$, výsledkem kvantilové funkce $x = F(y)^{-1}$ je hodnota $x$, pro jakou je výsledek náhodného pokusu se zadanou pravděpodobností $y$ menší nebo roven $x$. Jinými slovy hledáme taková $x$, kterým odpovídá určitá hodnota distribuční funkce $F(x)$. Hodnoty této funkce jsou tedy \emph{kvantily}.

\subsubsection{Rozdělení pravděpodobnosti}
\label{distr}
Někdy se též označuje jako distribuce pravděpodobnosti náhodné veličiny $X$. 
Rozdělení pravděpodobnosti každému jevu popsanému veličinou $X$ přiřazuje určitou pravděpodobnost. V diskrétním případě přiřazujeme pravděpodobnosti jednotlivým hodnotám (lze si představit jako samostatné body v grafu), ve spojitém případě pak intervalu hodnot náhodné veličiny. 

Rozdělení pravděpodobnosti je celá řada, z diskrétních je známé například \emph{binomické} ($n$ pokusů s rovnocennou pravděpodobností) či \emph{geometrické} rozdělení. Ze spojitých například \emph{normální rozdělení}, \emph{exponenciální rozdělení} nebo \emph{beta rozdělení}.

\subsubsection{Beta rozdělení}
\label{beta}
Beta rozdělení ${Beta}(\alpha, \beta)$ je spojité pravděpodobnostní rozdělení definované na intervalu $\langle0,1\rangle$. Rozdělení má dva vstupní parametry $\alpha$ a $\beta$ určující tvar. Rozdělení se používá k modelování chování náhodných veličin, které jsou omezené na konečné intervaly. 

\subsubsection{Bayesovská statistika}
Jedná se o moderní větev statistiky pracující s podmíněnou pravděpodobností. Základem bayesovské statistiky je známý \emph{Bayesův teorém} (často označovaný jako Bayesova věta) vyjadřující pravděpodobnost hypotézy ($H_j$) v závislosti na datech ($D$) a případně modelu ($M$). Lze pomocí ni stanovit pravděpodobnost, aniž bychom měli k dispozici známá fakta z minulosti. Oproti klasické statistice taktéž netestujeme hypotézy, ale provádíme \emph{odhady}. 

\subsubsection{Apriorní pravděpodobnost (prior)}
\label{prior}
Pravděpodobnost $P(H_j | M)$, označována jako \emph{prior}. Značí to, co víme nebo si myslíme předem, ještě před získáním dat (např. výsledky předchozích experimentů)~\cite{pst4}. Lze jí vyjádřit určitou míru nejistoty, například podíl voličů, kteří budou v budoucích volbách hlasovat pro nějakého konkrétního politika. 

\subsubsection{Aposteriorní pravděpodobnost (posterior)}
\label{poster}
Pravděpodobnost $P(H_j | D, M)$, označována jako \emph{posterior}. Udává výsledek celého snažení, tedy pravděpodobnost naší hypotézy v závislosti na předchozích znalostech (prior) a současně nových datech~\cite{pst4}.

Díky uvedeným pravidlům je možné s každou další objevenou skutečností zpřesňovat pravděpodobnost výchozí hypotézy. 

\subsubsection{Náhodný výběr}
\label{randomvyber}
Náhodného výběru se využívá k rozpoznání charakteru rozdělení (opakované pokusy dávají za stejných podmínek různé výsledky, které odpovídají hodnotám jednotlivých realizací náhodné veličiny). Jedná se o uspořádanou $n$-tici ($X_1$, $X_2$, \ldots, $X_n$) náhodných veličin $X_i$, $1 \leq i \leq n$, které jsou nezávislé a mají stejné rozdělení pravděpodobnosti~\cite{pst3}.

Zatímco \textbf{náhodným výběrem} označujeme $n$-prvkovou posloupnost nezávislých náhodných veličin $X_1$, $X_2$, \ldots, $X_n$, pojmem \textbf{výběr} budeme značit $n$-prvkovou posloupnost reálných čísel $x_1$, $x_2$, \ldots, $x_n$~\cite{pst5}. 

\subsubsection{Statistická inference}
\label{inferno}
\cite{pst5} Uvažujme pojem \emph{populace}, kdy populací myslíme náhodnou veličinu s jejím rozdělením pravděpodobnosti. Úkolem statistické inference je pak s použitím \textbf{výběru} z populace \emph{odhadnout parametr}, neboli číselnou hodnota platící pro celou populaci (tou může být například střední hodnota rozdělení, rozptyl a tak podobně).

Odhadem je myšleno získání číselné hodnoty nebo intervalu hodnot z výběru. Cílem je, aby měl takový odhad blízko skutečné hodnotě parametru.

Rozlišujeme dva typy odhadů, a to bodový, kdy odhadem je jedna hodnota, a intervalový, kdy je odhadem interval hodnot. 

\subsubsection{Multi-armed Bandits}
\label{sub:mabandit}
Jeden z klasických učících problémů zasahující do teorie pravděpodobnosti. Herní strategie je podobná filosofii tradičního výherního automatu (představujícího \emph{one-armed strategii}) s tím rozdílem, že multi-armed varianta má více herních pák, a proto lze v každém kole pro jednu hru volit mezi více automaty. Strategií se detailněji zabývá sekce~\ref{sec:multi}.

S pojmy vysvětlenými výše souvisí strategie v tom smyslu, že použitím bayesovské varianty provádíme opakovaný výběr z konečného počtu rozdělení, čímž se snažíme maximalizovat průměrnou hodnotu.

Toho lze využít například k cílenému doporučování reklamy nebo výběru personalizované úvodní stránky pro uživatele vstupujícího na naše stránky. Což je vlastně analogie k problému řešeného v této práci.

\subsection{Význam strojového učení při návrhu systému}
\label{sec:machine}

Jak vyplynulo z rešerše~\ref{chap:current} existujících řešení, vzhledem k povaze řešeného problému je nutné zaměřit se na metody \emph{strojového učení}. 

Těmito metodami lze dosáhnout generalizace vstupních instancí na správné výsledky nebo adaptovat existující systém na změny a reakce okolí. 

Typickým příkladem je vytvořit z dostupných dat model, jenž například dokáže:

\begin{itemize}
  \item predikovat cenu akcií za 6 měsíců (z aktuální výkonnosti společnosti a dostupných ekonomických dat),
  \item rozpoznat spam od regulérního e-mailu,
  \item u pacienta hospitalizovaného s infarktem predikovat riziko dalšího infarktu,
  \item napomoci společnostem zabývajících se internetovou reklamou v rozhodování se, kterou reklamní strategii použít k maximalizaci zisku.
\end{itemize}

Algoritmy strojového učení dělíme do taxonomie (nadtříd a podtříd) založené na požadovaném výsledku nebo typu vstupu, jenž máme k dispozici během trénování stroje. Algoritmů je celá řada, zmíním zde alespoň ty nejtypičtější. 

\begin{description}
  \item[Supervised learning]\footnote{učení s učitelem} je typ učení, které se používá v případě, že máme k našim trénovacím instancím na vstupu korektní výsledky. Pomocí kombinace trénovacích vstupních instancí a jejich požadovaných výsledků lze systém adaptovat na situaci, že dokáže sám předpovídat výsledky pro každé další platné vstupní instance~\cite{aihorizon}.
  
  Využití nachází například v oblastech rozpoznávání řeči či detekci spamu.
  \item[Unsupervised learning]\footnote{učení bez učitele} je již ze samotné podstaty absence učitele obtížným problémem. Učení bez učitele se používá k analýzu dat, když nemáme k dispozici informace od učitele (trénovací množinu). Pozorovaná data se mají vysvětlit pomocí matematických modelů.
  
  Používá se v oblasti rozpoznávání vzorů~\cite{hlavac}.
  \item[Reinforcement learning]\footnote{zpětnovazební učení nebo též učení posilováním} je oblast informatiky tykající se chování agentů~\ref{agent}. Jedná se o metodu, při které se agent učí, jakým způsobem má volit akce, aby nalezl optimální strategii pro dané prostředí.
  
  Jedná se o učení bez učitele. Agent sice dostává odezvu, ale přímo z prostředí, takže musí experimentovat a zjišťovat, které stavy jsou nějakým způsobem dobré, a kterým stavům je lepší se vyhnout.
  
  Průzkum probíhá na principu zpětné vazby v podobě odměny za akce dosahující cíle nebo trestu v opačném případě. Řeší se zde problém explorace vs. exploatace~\ref{sub:explo}. 
\end{description}

Rozlišujeme několik typů zpětnovazebního učení, například tzv. \emph{single-stage} (agent se snaží uplatňovat zpětnou vazbu ihned po každé provedené akci), oproti kterému stojí typ \emph{sekvenční} (agent uplatňuje zpětnou vazbu po obdržení série akcí). Dalšími typy jsou pak například \emph{pasivní} a \emph{aktivní} zpětnovazební učení přizpůsobující svůj vývoj na základě pevně dané strategie, respektive učení se a rozhodování o prováděných akcích za chodu systému~\cite{reinforcement}.

Algoritmus zpětnovazebního učení začíná při svém spuštění ve stavu nevědomí, kdy neví nic o daných okolnostech a začíná nabývat své vědomosti postupným testováním systému. Postupující dobou běhu (a tím, jak vstřebává data a vyhodnocuje výsledky) se učí rozpoznat, jaké chování je nejlepší.

\subsubsection{Zvolená strategie}
\label{sub:online}
Za nejvhodnější strategie, která by byla schopna plnit požadavky definované na tuto práci, jsem zvolil \emph{algoritmus zpětnovazebního učení}.

O strategii lze též mluvit jako o \emph{online učení}. Nutno zmínit, že slovem online zde není míněno něco ve smyslu internetu, ale ve smyslu neustále se vyvíjející aktualizace dat. Učící algoritmus v každém kole vykoná nějakou akci, přijme zpětnou vazbu a připíše si daný zisk či ztrátu.

Z matematického hlediska má online učení propojení na klasické online algoritmy, teorii (opakovaných) her a teorii pravděpodobnosti.

Díky těmto znalostem tak můžeme navrhovat pravděpodobností dynamické systémy, kterými lze modelovat složitá průmyslová zařízení nebo třeba výherní automat známý jako \emph{Multi-Armed Bandit}.

\subsection{Multi-armed Bandits algoritmus}
\label{sec:multi}

\subsubsection{Princip algoritmu}
\cite{camdp} Základ algoritmu si lze představit tak, že hráč stojí před $N$ výherními automaty (ty jsou podle dle strategie nazývány jako bandité) a v každém kole má možnost vybrat si jeden, na kterém bude hrát.

Strategie je formálně popsána jako skupina výnosových distribučních funkcí~\ref{cdf} $B = \{ A_1, A_2, \ldots, A_N \}$, kde $N$ je počet banditů (každý z banditů má tedy přiřazenu právě jednu distribuční funkci vyjadřující pravděpodobnost úspěchu). 

Hráč zpočátku nedisponuje žádnou informací o průběhu hry, ani o rozložení pravděpodobnosti úspěchu mezi bandity, a maximalizace výhry může dosáhnout pouze tím, že v každém kole vhodně vybere vždy jednoho z banditů.

Kdyby hráč věděl, u kterého z banditů je největší pravděpodobnost výhry, samozřejmě by vždy vybíral právě tohoto. Pravděpodobnosti výher u jednotlivých automatů jsou ale neznámé. Úkolem hráče tedy je nalézt nejlepšího banditu, a to tak rychle, jak jen to je možné, aby jej mohl co nejvíce využívat~\ref{sub:explo}.

\begin{description}
	\item[Návrh strategie]
	
Návrh strategie spočívá v tom, že systém jednotlivé bandity nejdříve testuje~\ref{inferno} za účelem získání znalostí nutných pro další vývoj. Jakmile nabude více znalostí, je možné zaměřit se na bandity, kteří poskytují díky zužitkovaným znalostem největší odměnu. 

Úkol je komplikován stochastickou povahou banditů. Suboptimální bandita může přinášet spoustu výher, což by nás mohlo přimět uvěřit, že právě tento bandita je tím nejlepším. Podobně ale uvažovat i naopak – nejlepší bandita totiž může zpočátku přinášet spoustu proher.

Na místě jsou dvě otázky:

\begin{itemize}
	\item Měli bychom dávat stále šanci i banditům, u kterých často prohráváme, nebo na ně zanevřít a štěstí zkoušet u jiných?
	\item Pokud nalezneme banditu, který nám přináší \emph{docela dobré} výsledky, měli bychom se s ním spokojit a nadále maximalizovat svou výhru pouze u něj? Nebo se vyplatí zkoušet i nadále další bandity v naději, že se povede nalézt ještě lepšího?
\end{itemize}

Tato dilemata jsou odborně nazývána jako explorace a exploatace.	
\end{description}

\subsubsection{Explorace vs. exploatace}
\label{sub:explo}

\begin{description}
  \item[Explorace] Nacházení nových oblastí hledání, kdy agent nevyužívá předchozích znalostí (agent stále zkouší nové akce, jejichž výsledek nezná).
  \item[Exploatace] Využívání stávajících znalostí. Hrozí uváznutí v lokálních extrémech. (agent provádí akce, o kterých ví, že mu přinášejí užitek). 
\end{description}	

Optimální strategie nemůže být ani čistě explorační, ani čistě exploatační. Hledá se vyvážený kompromis.

\subsection{Bayesian Bandits}
\label{bayes}
Nalézt optimální řešení tedy nepatří k triviálním problémům. Systému může trvat léta, než se k němu dopracuje. Naštěstí existuje spousta \emph{přibližně optimálních} řešení.

Jedním z řešení je algoritmus zvaný \emph{Bayesian Bandits}. Algoritmus přímo souvisí s učením založeným na zpětné vazbě.

Bayesovské řešení začíná prior~\ref{prior} stanovením pravděpodobností výhry pro každého banditu. Hodnoty jsou v rozmezí $\langle0,1\rangle$. Jak již bylo řečeno, každého banditu reprezentuje jedna distribuční funkce.

V každém kole, kterých je v případě mnou vytvářeného systému nekonečně (neboť kola jsou závislá na žádostech uživatelů, kteří přistupují k systému – standardní použití Multi-armed Bandits pracuje s konečným počtem stavů), probíhá následující proces:

\begin{enumerate}
	\item pro každého z $N$ banditů proveď prior~\ref{prior} (počty pokusů, výher, \ldots) výběr z náhodné veličiny $X_b$~\ref{randomvel} bandity $b$
	\item ze získaných dat vyber~\ref{randomvyber} banditu s největší hodnotou předchozího výběru, například $B = argmax X_b$	
	\item pozoruj výsledek vrácený banditou $B$ a proveď prior aktualizaci tohoto bandity.
	\item vrať se na krok 1
\end{enumerate}

Počáteční prior pravděpodobnost je u každého bandity Beta rozdělení~\ref{beta} ${Beta}(\alpha = 1, \beta = 1)$ (uniformní rozdělení).

Pozorovaná náhodná veličina $X$ (výhra či prohra, tedy 1 nebo 0) je binomická. Posterior~\ref{poster} pravděpodobnost se po provedení pokusu přizpůsobuje novému rozdělení:

\begin{center}
${Beta}(\alpha = 1 + X, \beta = 1 + 1 - X)$.
\end{center}

V případě jakéhokoliv úspěchu se provádí navýšení pravděpodobnosti, se kterou bude algoritmus znovu vybrán. V případě neúspěchu se tato pravděpodobnost exponenciálně snižuje. V každé další hře se již systém rozhoduje s touto pravděpodobností (mezí explorací a exploatací).

Pokud tedy chceme odpovědět na dřívější otázku, zda bychom měli dávat stále šanci i banditům, u kterých často prohráváme, nebo na ně zanevřít a zkoušet štěstí u jiných, tento algoritmus nám navrhuje to, abychom prohrávající bandity přímo nevyřazovali, ale vybírali je stále méně častěji, jakmile získáme dostatek jistoty, že existují i lepší bandité. 

Existuje tu nenulová šance, že prohrávající bandita dosáhne statusu $B$, pravděpodobnost této šance se ale snižuje s rostoucím počtem odehraných kol. 

Obrázek~\ref{fig:posteriors} znázorňuje postup pro problém tří banditů ($N = 3$), jakým se algoritmus učí s rostoucím počtem her. Přerušované čáry pod grafy hustoty každého rozdělení reprezentují skryté reálné pravděpodobnosti (v obrázku mají hodnoty $0.85$, $0.60$, $0.75$). Z uvedeného příkladu vyplývá, že o skryté pravděpodobnosti se až tolik nestaráme. Daleko větší význam pro nás má výběr nejlepšího bandity, což je vidět na distribuci červeného bandity. Ta je velice široká, což představuje skutečnou neznalost o tom, jak velkou skrytou pravděpodobností bandita disponuje. O pravděpodobnosti tedy nemáme nejmenší tušení, jsme si ale docela jistí tím, že bandita není nejlepší. Algoritmus se proto rozhodne ignorovat jej.

\begin{figure}\centering
	\includegraphics[width=1.0\textwidth]{obr/posteriors.png}
 	\caption[Vizualizace sekvenčního učení řešení od jedné do tisíce her.]{Vizualizace sekvenčního učení řešení od jedné do tisíce her. Zdroj: \cite{camdp}}\label{fig:posteriors}
\end{figure}	

\subsubsection{Zpětná vazba a její vliv na vývoj adaptibilního systému}
TODO

\subsubsection{Stanovení míry učení}
Vzhledem k tomu, že prostředí se rychle mění v čase, je nutné stanovit míru učení. Technicky vzato je standardní Bayesian Bandits algoritmus schopen učit se sám pomocí aktualizovaných parametrům vstupujících do ${Beta}$ rozdělení po každé hře. Stanovením vhodné míry učení lze docílit toho, že algoritmus se bude přizpůsobovat měnícímu se prostředí rychleji.

Pokud stanovíme míru $<$ 1, algoritmus bude předchozí výsledky zapomínat rychleji a častěji bude zkoumat nové možnosti. Míra $>$ 1 implikuje naopak to, že algoritmus bude sázet na časnější dřívější výhry, čímž ale riskuje to, že se nedokáže rychle adaptovat na náhlé změny (je více imunní vůči rychle se měnícímu prostředí).

\chapter{Praktická část}
\section{Analýza a návrh řešení}
\label{chap:analysis}

Tato kapitola je celá věnována analýze požadovaného chování systému.

Nejprve se budu zabývat požadavky, které vyplynuly z úvodních konzultací s vedoucím práce a též po vlastním zkoumání řešeného problému. Se znalostí těchto požadavků pak bude možné provést hrubý návrh architektury systému včetně technického řešení komponent, jimiž bude systém disponovat.

S ohledem na výstupy získané v této kapitole bude možné provést implementaci systému.

\subsection{Požadavky}
\label{sec:req}
Za účelem vyšší přehlednosti jsem se rozhodl související požadavky strukturovat do zastřešujících skupin dle typu modulu, který je bude obsluhovat.

Vyvíjenými součástmi jsou:

\begin{itemize}
  \item \textbf{adaptibilní systém pro doporučování obsahu,}
  \item \textbf{sada základních algoritmů určených k doporučování,}
  \item \textbf{RESTful API pro manipulaci s doporučovacími algoritmy a systémem.}
\end{itemize}

\subsubsection{Požadavky na adaptibilní systém}

\begin{itemize}
	\item Systém bude klást důraz na zpětnou vazbu, podle které bude přizpůsobovat své chování.
	\item Systém bude zpětnou vazbu přijímat na principu odměny za dobré doporučení (přičítání v poměru) a trestu za špatné (odečítání v poměru).
	\item Systém bude v pravidelných intervalech ukládat do databáze svůj aktuální stav.
	\item Systém bude schopen v případě pádu aplikace a po jejím opětovném spuštění načíst naposledy uložený stav.
	\item Systém bude veškeré své operace týkající se doporučování provádět a vyhodnocovat v reálném čase (live read \& live write).
	\item Systém bude schopen automaticky se přizpůsobovat vývoji v čase normalizováním ukládaných hodnoty (z důvodu prevence proti přetečení datových typů).	
	\item Systém bude na každou klientskou žádost vracet příslušnou odpověď (i chybovou) – neexistuje nic jako odpověď \emph{null}.	
\end{itemize}

\subsubsection{Požadavky na sadu základních algoritmů}
\begin{itemize}
	\item Algoritmus bude dle typu přijímat různé parametry (uživatel, položka atd.), které využije pro doporučení obsahu.
	\item Algoritmus bude komunikovat s daty uložených v Apache Solr a nad těmito daty provádět doporučovací operace.
\end{itemize}

\subsubsection{Požadavky na RESTful API}
\begin{itemize}
	\item Rozhraní bude vytvářet kolekce se seznamem algoritmů určených pro kombinování a následnou predikci.
	\item Rozhraní bude zpracovávat uživatelské žádosti o radu.
	\item Rozhraní bude odpovídat na uživatelské žádosti o radu formou informace, který algoritmus pro doporučení obsahu by měl být v danou chvíli zvolen.
	\item Rozhraní bude zpracovávat informace od uživatelů o tom, pro jaký algoritmus doporučení obsahu se rozhodli.
	\item Rozhraní bude zpracovávat uživatelské žádosti o doporučení vybraným algoritmem.	
	\item Rozhraní bude navracet doporučení realizované vybraným algoritmem.
	\item Rozhraní bude zpracovávat informace od uživatelů zasílajících zpětnou vazbu týkající se algoritmu, kterým si nechali doporučit obsah.
	\item Rozhraní bude zpracovávat informace od uživatelů zasílajících zpětnou vazbu týkající se doporučených položek (informaci, že 1 konkrétní uživatel dělá něco s 1 konkrétním dokumentem).
	\item Rozhraní bude mazat či zneviditelňovat z výsledků pro doporučení již nerelevantní položky.
\end{itemize}

Dle disciplín softwarového inženýrství lze výčet uvedený výše označit za \textbf{funkční požadavky}.

Definujme nyní i tzv. \textbf{nefunkční požadavky}, které specifikují vlastnosti a omezující podmínky kladené na systém:

\begin{itemize}
	\item Systém bude postaven na platformě Java.
	\item Pro uchování informací o uživatelích, položkách a jejich vzájemné interakci bude využita platforma pro vyhledávání v textu Apache Solr.
	\item Systém bude umožňovat přístup aplikacím třetích stran prostřednictvím RESTful webových služeb (vychází ze zadání).
	\item Systém bude postaven tak, aby se dal snadno parametrizovat. 
	\item Systém bude připraven na situaci, že jej bude využívat více uživatelů současně.
	\item Systém poběží jako samostatná aplikace na serveru naslouchající na TCP portu. Veškerá komunikace s ní bude probíhat formou zasílání zpráv a volání procedur.
	\item Pro snadné nasazení a testování systému na libovolné pracovní stanici bude nutné vytvořit Chef cookbook/recipe\footnote{\url{http://community.opscode.com/}}.
\end{itemize}

\subsection{Architektura platformy}

Pro zdárnou implementaci platformy splňující všechny požadavky vzešlé z analýzy výše je třeba důkladně zvážit, jaké komponenty bude obsahovat.

Diagram~\ref{fig:recommeng} znázorňuje abstraktní návrh architektury takové platformy. Mou snahou bylo zachytit přítomnost jednotlivých komponent v systému, formu jejich vzájemné komunikace a spolupráce a též základní interakci uživatele se systémem.

\begin{figure}\centering
	\includegraphics[width=1.0\textwidth]{obr/DIPLOMKA_env.pdf}
 	\caption[Abstraktní návrh architektury a komponent adaptibilního systému]{Abstraktní návrh architektury a komponent adaptibilního systému, ve kterém je též vidět základní interakce uživatele se systémem.}\label{fig:recommeng}
\end{figure}	

\subsubsection{Server}

Stěžejní serverovou komponentou je adaptibilní systém~\ref{sec:recommeng}. Ten jsem pracovně nazval jako \textbf{Recommeng} systém (zkratka pro recommendation engine), abych o něm nemusel již nadále mluvit jako o \emph{adaptibilním systému} či \emph{systému pro kombinování metod}. 

V rámci ucelenosti zde uvádím přehled všech komponent nacházející se na serverové straně:

\begin{description}
	\item[Aplikační server]
	
Na aplikačním serveru poběží dvě aplikace. 

\begin{description}
	\item[Webová aplikace s rozhraním pro snadnou komunikaci s klienty.]
	(viz diagram~\ref{fig:recommeng}, komponenta \emph{Web Application 1}) Aplikace bude mít na starosti obsluhu klientských požadavků na systém prováděných prostřednictvím protokolu HTTP. Zároveň bude disponovat sadou algoritmů, které lze použít pro doporučení obsahu. Dále bude aplikace obstarávat komunikační režii s druhou aplikací běžící na aplikačním serveru (\emph{Web Application 2}), kterou je platforma pro vyhledávání v textu – Apache Solr.

	\item[Apache Solr]
	(viz diagram~\ref{fig:recommeng}, komponenta \emph{Web Application 2}) Přítomnost této aplikace vychází z nefunkčních požadavků. Apache Solr funguje jako samostatná komponenta umožňující fulltextové vyhledávání (detaily v kapitole~\ref{chap:impl}).
\end{description}	
\end{description}

\begin{description}
	\item[Databáze]

Kvůli potřebě ukládat uživatelem vytvářené kolekce, též průběžný stav aplikace (časové snímky), a také kvůli snadnému obnovení znalostí systému v případě přerušení běhu, je nutné zapojit do návrhu Database Management System (DBMS).

Volba DBMS hraje důležitou roli i při škálování aplikací. V minulosti tolik používané standardní relační DBMS mohou způsobovat zpoždění při provádění čtení/zápisu a v některých případech hrát roli úzkého hrdla aplikace (bottleneck).

Ohledně tohoto problému by možná stálo za úvahu prozkoumat možnosti použití NoSQL databází, které jsou již ze svého principu navrženy pro spolupráci s aplikacemi zaměřenými na výkon a škálovatelnost.
\end{description}

\begin{description}
	\item[Recommeng systém]

Komunikaci s aplikací bude umožňovat systém pro zasílání zpráv (Messaging System) s využitím fronty zpráv (Message Queue). Toto řešení je zde nasnadě kvůli očekávání většího množství žádostí směřujících na systém a snadnější škálovatelnosti aplikace. Obecný příklad takového MQ systému znázorňuje obrázek~\ref{fig:vitvarMq}

\begin{figure}\centering
	\includegraphics[width=1.2\textwidth]{obr/vitvar_mq.png}
 	\caption[Příklad MQ systému s producentem zpráv a konzumenty]{Příklad MQ systému s producentem zpráv a konzumenty. Zdroj: \cite{vitvarMq}}\label{fig:vitvarMq}
\end{figure}	

Recommeng systém bude taktéž komunikovat s databází kvůli nutnosti ukládání informací o stavu, respektive kvůli možnosti načíst poslední uložený stav při novém startu aplikace.

Veškerá data pro výpočet a predikci budou jinak udržována přímo ve vnitřní paměti (uvnitř JVM).
\end{description}

\subsubsection{Klient}

Klientská strana není nikterak složitá. Potenciální uživatel aplikace má v zásadě dvě možnosti, jak s platformou komunikovat:

\begin{itemize}
	\item Jen a pouze zasíláním žádostí na REST API.
	\item Kombinací zasílání žádostí na REST API společně s přímou komunikací s Recommeng systémem prostřednictvím fronty zpráv.
\end{itemize}

Některé ze systémových funkcionalit nelze bez komunikace s REST API využívat. Do této kategorie spadá například přidání nového vztahu k položce ve fulltextovém indexu nebo zaslání žádosti o doporučení obsahu některým z podporovaných algoritmů. 

Přímé spojení s platformou skrze frontu zpráv bez nutnosti zapojení prostředníka v podobě REST API by ale měly umožňovat všechny možnosti použití Recommeng systému. Jmenovitě vytváření kolekcí se seznamem algoritmů, dále zasílání žádostí o radu pro výběr algoritmu a též metody informující systém o uživatelově chování jako zvolení konkrétního algoritmu nebo zaslání zpětné vazby o doporučení. 

V diagramu~\ref{fig:recommeng} jsem se snažil zachytit různé formy komunikace klienta se systémem. Pro lepší názornost jsou jednotlivé žádosti barevně odlišeny. Ty lze považovat za modelové případy užití inspirované systémovými požadavky.

\begin{description}
	\item[Zaslání zpětné vazby k doporučené položce]

\emph{Pozn.} V diagramu~\ref{fig:recommeng} je klient odlišen červenou barvou. 

Jedná se o klienta přidávajícího nový vztah mezi položkou a jejím uživatelem do úložiště.

\begin{itemize}
	\item klient zašle žádost na rozhraní
	\item aplikace (Web Application 1) za rozhraním se spojí s indexem
	\item v případě zdárného průběhu se přidá do indexu informace o tom, že 1 uživatel dělá něco s 1 dokumentem
	\item klient obdrží odpověď s výsledkem žádosti
\end{itemize}

\end{description}

\begin{description}
	\item[Žádost o radu při výběru metody pro doporučení obsahu]
\label{subsub:purple}

\emph{Pozn.} V diagramu~\ref{fig:recommeng} je klient odlišen fialovou barvou.

V diagramu je znázorněna situace, kdy klient zasílá platformě zpětnou vazbu ohledně doporučení, které dostal. Tato varianta může ale též představovat situaci, kdy klient žádá systém o radu, kterou metodou si má nechat doporučit obsah ve své budoucí žádosti o doporučení (viz varianta~\ref{subsub:yellow}).

\begin{itemize}
	\item klient zašle žádost na rozhraní
	\item aplikace (Web Application 1) za rozhraním se pokusí přistoupit k frontě zpráv
	\item pokud fronta existuje, žádost je přidána do fronty pro zpracování konzumentem (Recommeng systém)
	\item konzument zpracuje žádost a zasílá odpověď, kterou systém zpráv předá zpět do aplikace
	\item klient obdrží odpověď s výsledkem žádosti
\end{itemize}
\end{description}

\begin{description}
	\item[Žádost o doporučení konkrétním algoritmem]
\label{subsub:yellow}

\emph{Pozn.} V diagramu~\ref{fig:recommeng} je klient odlišen žlutou barvou.

Situace znázorňuje situaci, kdy klient poptává doporučení obsahu konkrétním algoritmem. Toto doporučení klient poptává na základě odpovědi na žádost, která mu byla udělena systém (viz varianta~\ref{subsub:purple})). 

\begin{itemize}
	\item klient zašle žádost na rozhraní
	\item aplikace (Web Application 1) za rozhraním zvolí vybraný algoritmus pro doporučení
	\item algoritmus přistoupí k datům v indexu, nad kterými se provede doporučení
	\item klient obdrží odpověď s výsledkem žádosti
\end{itemize}
\end{description}

\begin{description}
	\item[Komunikace bez využití RESTful API]

\emph{Pozn.} V diagramu~\ref{fig:recommeng} je klient odlišen modrou barvou.

Tento klient se rozhodl nevyužít možnosti komunikovat prostřednictvím REST API. Svou žádost zasílá přímo do fronty zpráv.

\begin{itemize}
	\item klient zašle žádost do fronty
	\item pokud fronta existuje, žádost je přidána do fronty pro zpracování konzumentem (aplikace Recommeng)
	\item konzument zpracuje žádost a zasílá klientovi odpověď
\end{itemize}

\end{description}

\subsection{Recommeng systém}
\label{sec:recommeng}

\begin{figure}\centering
	\includegraphics[width=1.0\textwidth]{obr/ensembleDiagram.pdf}
 	\caption[Zjednodušený návrh spolupráce tříd v adaptibilním systému.]{Zjednodušený návrh spolupráce tříd v adaptibilním systému.}\label{fig:recommengNavrh}
\end{figure}	

\subsubsection{Komunikace s frontou zpráv Recommeng systému}

Výše jsme měli možnost poznat dva způsoby komunikace uživatele s doporučovací platformou. Dalším úkolem je navrhnout formát, jakým si budou vyměňovat producent s konzumentem data prostřednictvím volání vzdálených procedur Recommeng systému.

Vzhledem k obecné známosti protokolu HTTP jsem se rozhodl napodobit jeho chování a zachovat sémantiku:

\begin{itemize}
	\item metoda (method)
	\item cesta (path)
	\item tělo zprávy (body)
\end{itemize}

Podobně jako v HTTP, i v případě mnou navrhované komunikace bude na každou žádost ve tvaru \emph{method, path} a \emph{body} přicházet odpověď ve tvaru \emph{status} a \emph{body} s využitím různých návratových kódů pro stav (status).

\subsection{Rozhraní}

Platforma poskytuje API pro interakci se systémem a daty formou RESTful (HTTP implementace REST~\ref{rest}). Každý uživatel tak může interagovat s rozhraním prostřednictvím zveřejněných endpointů.

Z prováděné analýzy vyplynuly požadavky na aplikační rozhraní takové, že je lze rozdělit do tří skupin dle podstaty úkolu, který mají plnit. K dispozici je diagram~\ref{fig:rest}, který by měl celou věc osvětlit. 

\begin{figure}\centering
	\includegraphics[width=1.0\textwidth]{obr/DIPLOMKA_rest.pdf}
 	\caption[Ukázka REST endpointů navrhovaného adaptibilního systému]{Ukázka REST endpointů navrhovaného adaptibilního systému}\label{fig:rest}
\end{figure}	

\subsubsection{Rozhraní pro Recommeng}

\begin{figure}\centering
	\includegraphics[width=1.0\textwidth]{obr/rest1.pdf}
 	\caption[Zjednodušený návrh spolupráce tříd v adaptibilním systému.]{Zjednodušený návrh spolupráce tříd v adaptibilním systému.}\label{fig:recommengRestNavrh}
\end{figure}	

Komunikace s rozhraním by měla umožňovat vytvářet v Recommeng aplikaci kolekce s identifikátory algoritmů, jenž budou zapojeny do kombinování a predikce. 

K tomu účelu bude sloužit endpoint:

\begin{verbatim}
	/recommeng/ensemble/collection
\end{verbatim}

Pokud uživatel zašle metodou POST žádost na tento endpoint (obsahující identifikátor kolekce a seznam algoritmů), v případě dosavadní neexistence v systému bude kolekce vytvořena a připravena k predikci. 

Dále by měla existovat možnost zaslat na kolekci prosbu o predikci nejlepšího jejího algoritmu pro doporučení.

\begin{verbatim}
	/recommeng/ensemble/collection/{collection-id}
\end{verbatim}

Toho dosáhneme žádostí s metodou GET, uvedením identifikátoru kolekce a případným specifikováním požadovaného výstupu (zda chceme vrátit jen nejlepší možnost či všechny možnosti seřazené sestupně od nejlepšího) v parametru dotazu.

Kvůli učení a vývoji znalostí systému je nezbytně nutné mít možnost zaslat informaci o výběru konkrétního algoritmu a též zpětnou vazbu vyjadřující, jak byl žádající uživatel s navrhovanou variantou spokojen.

\begin{verbatim}
	/recommeng/ensemble/collection/{collection-id}/{algorithm-id}
\end{verbatim}

Na endpoint výše v takovém případě zašleme metodou PUT upřesňující informaci o operaci, kterou chceme systému sdělit (výběr vs. zpětná vazba).

\subsubsection{Rozhraní pro sadu základních algoritmů}

\begin{figure}\centering
	\includegraphics[width=1.0\textwidth]{obr/rest2.pdf}
 	\caption[Zjednodušený návrh spolupráce tříd v adaptibilním systému.]{Zjednodušený návrh spolupráce tříd v adaptibilním systému.}\label{fig:recommengRestNavrh2}
\end{figure}	

Bude se jednat o jednoduchý endpoint, který si při žádosti vystačí s metodou GET.

\begin{verbatim}
	/recommeng/algorithms/{core-id}/{algorithm-id}
\end{verbatim}

Úkolem je zpracovat žádost uživatele o doporučení algoritmem, jehož identifikátor je uveden v cestě. 

Hledání doporučení bude provedeno nad dokumenty ze specifikovaného indexu (identifikátor indexu je též nutno uvést). V parametrech dotazu lze specifikovat další vstupy pro doporučení jako limit vrácených výsledků, identifikátor pro doporučení článků z té samé skupiny a další.

\subsubsection{Rozhraní pro úložiště dat}

Důležité rozhraní umožňující zaznamenat chování uživatele vzhledem ke sledovaným položkám.

\begin{verbatim}
	/recommeng/cores/{core-id}/document
\end{verbatim}

Prostřednictvím metody POST budou zasílány veškeré informace o položce (u článku např. identifikátor, text, skupina, datum publikace) a jejím uživateli (identifikátor), která má být uložena do fulltextového indexu. Druhou podporovanou metodou je metoda DELETE pro vyřazení položky z doporučování. Metoda je použita v žádosti na týž endpoint jako metoda POST, pouze je nutné v parametru dotazu specifikovat identifikátor článku (z toho důvodu, že identifikátorem článku může být cokoliv, například URL adresa).
			
\subsection{Sada algoritmů}

Identifikace základní sady algoritmů určených pro kombinování je jeden z požadavků na systém plynoucí přímo ze zadání. 

Uživatel žádající o radu pro výběr nejlepšího algoritmu obdrží od systému identifikátor reprezentující tento algoritmus. 

Algoritmy pro doporučování vyhodnocují především informace o uživateli, položkách a hodnocení. Ukládány jsou ale i další údaje, například datum zveřejnění položky či její popis (u článku se může jednat o text zprávy). Také s těmito informacemi mohou doporučovací algoritmy pracovat. 

\subsubsection{Algoritmus náhodného výběru}

Jak je patrné již z názvu, tento algoritmus vybírá položky pro doporučení naprosto náhodným způsobem. Jeho hlavním úkolem je být zde pro srovnání s ostatními algoritmy. 

\subsubsection{Algoritmus výběru dle nejnovějších položek}

Doporučování dle nejnovějších položek je dalším z algoritmů s naivním přístupem k problému. Položky budou v tomto případě doporučovány sestupně dle zveřejněného data. 

\subsubsection{Algoritmus výběru nejlépe hodnocených položek}

Jedná se o první algoritmus založený na složitějším výpočtu. Položky vzešlé z doporučení budou dle určitých parametrů nějakým způsobem lepší než ostatní, které se v doporučení neobjevily. Takovým parametrem může být například hodnocení na škále od 1 do 5, počet pozitivních hodnocení, souhrnné číslo udávající počet přečtení článku nebo jiný z mnoha způsobů vyjádření zájmu o položku. 

\subsubsection{Algoritmus výběru dle podobnosti obsahu}

Algoritmus se snaží na základě podobnosti obsahu nalézt pro položku několik jí podobných položek z databáze. Podobnost se určuje porovnáním jednotlivých parametrů, například tagů, nadpisů nebo celého textu článku.

\subsubsection{Algoritmus kolaborativního filtrování}

Algoritmus je založen na modelu dřívějšího chování uživatele v systému. Model je většinou konstruován z chování většího množství uživatelů s podobným vkusem. V podstatě lze říci, že doporučení jsou založena na automatické spolupráci více uživatelů a výběru těch, kteří mají co nejpodobnější preference či chování.

Rozlišují se dva hlavní způsoby filtrování.

\begin{description}
	\item[User-based]

\emph{``You may like it because your friends liked it.''}~\cite{cf}

Aneb filtrování založené na uživatelích. Jedná se o starší variantu kolaborativního filtrování. Podstatou je vzít na základě určité podobnosti skupinu uživatelů (zdroj~\cite{cf} udává cca 20 až 50) s podobných vkusem jako má uživatel, pro něhož je doporučení konstruováno, a poté předpovědět, jak moc zajímavá by pro uživatele byla pro něj dosud neznámá položka, se kterou jsou spojení uživatelé se stejným vkusem.
\end{description}

\begin{description}
	\item[Item-based]

\emph{``You tend to like that item because you have liked those items.''}~\cite{cf}

Aneb filtrování založené na položkách, které použila v roce 2001 jako první společnost Amazon. Myšlenka je taková, že uživatel, který si v minulosti zakoupil nějakou položku, bude v budoucnu při dalším nákupu vyhledávat položku podobnou. Například předpověď toho, co si uživatel zakoupí v budoucnu, lze uskutečnit analýzou historie nákupů uživatele~\cite{itemcf}. 
\end{description}

\section{Principy a technologie}
\label{sec:sysanalys}

\subsection{RESTful API}
\label{rest}
\subsubsection{REST}
\textbf{REpresentational State Transfer (REST)} je architektonický styl definující určitá pravidla a vlastnosti návrhu API webových služeb orientovaných na zdroje. REST je silně založen na architektuře Klient-Server (server poskytuje přístup ke zdrojům, klient k nim může přistupovat a modifikovat je) a k jeho realizaci je možné využít protokolu HTTP (takovou realizaci pak nazýváme jako RESTful). Role tohoto protokolu zde není nikterak náhodná, neboť autorem REST není nikdo jiný než Roy Fielding, jenž je u protokolu HTTP podepsaný jako spoluautor~\cite{Fielding:2000:ASD:932295}. 

Díky protokolu HTTP lze následovat mnoho pravidel návrhu RESTful API, například přítomnost adresovatelných zdrojů, kdy je každý zdroj adresovatelný pomocí Uniform Resource Identifier (URI). RESTful pro manipulaci se svými zdroji používá též HTTP metody (GET, POST, PUT, DELETE, ale i další, například OPTIONS či PATCH). Další vlastností je užívání standardních stavových kódů\footnote{Definici všech stavových kódů viz \url{http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html}.} HTTP (typicky 2xx, 3xx, 4xx, 5xx) v odpovědi na žádost či bezestavová komunikace.

Data mohou být reprezentována v rozličných formátech jako XML, JSON či YAML.

Padla zde zmínka o bezestavosti. V případě REST k vyjádření přechodů mezi stavy aplikace používáme odkazy. Tento princip je nazýván jako \emph{Hypertext as the Engine of Application State} (HATEOAS). 

\subsubsection{Jersey (JAX-RS)}
\textbf{Java API for RESTful Web Services (JAX-RS)}\footnote{https://jax-rs-spec.java.net} je standard definovaný v Java Specification Request 311\footnote{https://jcp.org/en/jsr/detail?id=311}. Jedná se o specifikaci pro RESTful webové služby implementované v programovacím jazyce Java.

Pomocí JAX-RS lze s využíváním anotací jednoduše a přehledně definovat sémantiku jednotlivých tříd a jejich metod z hlediska využití v architektuře REST. Příklady anotací jsou \emph{@Path(relativni\_cesta)} pro specifikaci relativní cesty zdroje, \emph{@GET} či \emph{@POST} specifikující typ žádosti nebo třeba \emph{@QueryParam} pro přiřazení parametru HTTP dotazu k hodnotě parametru příslušné metody třídy.

Pro účely implementace rozhraní systému Recommeng jsem zvolil vzhledem k předchozím zkušenostem referenční implementaci tohoto standardu v podobě frameworku \textbf{Jersey 2.x}. 

\subsection{Fronta zpráv a síťová komunikace}

\subsubsection{ØMQ}
\textbf{ØMQ (ZeroMQ)}\footnote{http://zeromq.org} je vysoce výkonná\footnote{Viz výkonnostní testy na oficiální stránce \url{http://zeromq.org/results:_start}.} síťová knihovna napsaná v programovacím jazyce C++ vhodná k nasazení v distribuovaných a vícevláknových aplikacích, které vyžadují velkou škálovatelnost. S jejím využitím lze poměrně snadno navrhnout komplexní komunikační systém. Ke komunikaci užívá socketů\footnote{Socket je mechanismus, kterým je možno zprostředkovat lokální čí vzdálenou komunikaci dvou uzlů, která má charakter klient/server~\cite{socket}.}. Duchovním otcem a spoluautorem knihovny je slovenský expert na oblast messaging middleware Martin Sústrik\footnote{\url{http://250bpm.com/contact}}.

Hned na úvod je nutné sdělit, že se nejedná o klasický messaging system (message-oriented middleware) takového typu, jakým je například Apache ActiveMQ\footnote{\url{http://activemq.apache.org}} a jemu podobné systémy. Takové systémy jsou většinou hotová řešení připravená k okamžitému nasazení a integraci s dalšími službami. 

Filosofie ZeroMQ je jiná, neboť jde především o multiplatformní knihovnu určenou k programovému využití (nabízí podporu více než 30 programovacích jazyků\footnote{TODO}). Pomocí jednoduchého socketového API umožňuje programátorovi sestavit si vlastní messaging system dle svého nejlepšího uvážen. Programátor využívá ze strany API veškerou podporu usnadňující práci se sítí a s trochou nadsázky lze prohlásit, že se stará pouze o zasílání zpráv. Sama socketová komunikace je výrazně zjednodušena.

Knihovna nám navíc dává kompletní svobodu v tom, jakým způsobem zakódujeme naši zprávu (JSON, BSON nebo jakýkoliv vlastní navržený formát).

Podporovány jsou čtyři protokoly pro komunikaci~\cite{zeromq1}:

\begin{description}
	\item[tcp] jako model síťově založeného přenosu (procesy na jedné síti)
	\item[inproc] jako model komunikace vláken uvnitř jednoho procesu
	\item[ipc] jako model komunikace mezi procesy (procesy out-of-box)
	\item[multicast]	komunikující skrze PGM\footnote{\url{http://tools.ietf.org/html/rfc3208}}.
\end{description}

Knihovna také definuje základní vzory zasílání zpráv, ať už se jedná o doručování zpráv na jednotlivé uzly, mapování uzlů na vlákna, procesy či umisťování zpráv do fronty\footnote{\url{http://zguide.zeromq.org/page:all\#Messaging-Patterns}}. Každý vzor zároveň určuje jinou síťovou topologii.

Základními vzory jsou:

\begin{itemize}
	\item Request-reply
	\item Pub-sub
	\item Pipeline		
	\item Exclusive pair
\end{itemize}

Nejvhodnějším vzorem pro mou práci je díky nátuře navrhovaného systému (zasílání zpráv a odpovědi na ně) vzor Request-reply, jehož konkrétní použití následuje záhy v sekci \nameref{sec:impl}. Ostatní vzory nemá smysl v rámci této práce popisovat.

Pro účely Recommeng systému jsem se rozhodl využít čistou Java implementaci knihovny ZeroMQ v podobě knihovny \textbf{jeroMQ}\footnote{\url{https://github.com/zeromq/jeromq}}. Z výkonnostního hlediska za původním řešením zaostává jen nepatrně\footnote{Viz srovnávací testy \url{https://github.com/zeromq/jeromq/wiki/Perfomance}.} a navíc je mnohem jednodušší integrovat ji do vyvíjené aplikace prostým přidáním knihovny do projektu.

\subsection{Úložiště dat}

\subsubsection{Apache Solr}
\textbf{Apache Solr}\footnote{\url{https://lucene.apache.org/solr}} je populární\footnote{Viz seznam serverů využívajících služeb Solr \url{https://wiki.apache.org/solr/PublicServers}} open-source platforma pro vyhledávání napsaná v programovacím jazyce Java. Jejími charakteristickými vlastnosti jsou podpora pro fulltextové vyhledávání, fasetové vyhledávání (analogie ke konstrukci GROUP BY v RDBMS), dobrá škálovatelnost pomocí kešování a distribuovaného vyhledávání, využívání vyhledávací konstrukce \emph{more like this}, o které bude řeč v sekci~\ref{sec:alg}, a také například tzv. \emph{near real-time indexing}\footnote{\url{https://cwiki.apache.org/confluence/display/solr/Near+Real+Time+Searching}} (dokumenty je možné vyhledávat téměř ihned po jejich zaindexování).

Z hlediska architektury programu jde o samostatný server pro fulltextové vyhledávání běžící v servletovém kontejneru (například Apache Tomcat). K indexaci a fulltextovému vyhledávání využívá ve svém jádru knihovnu Apache Lucene. 

\textbf{Apache Lucene}\footnote{\url{http://lucene.apache.org/core}} je vysoce výkonná knihovna pro účely vyhledávání v textu a indexování.

Vstupem pro indexaci jsou dokumenty. Každý takový dokument obsahuje množinu elementů, kde je tento element nazvaný jako \emph{field}). Každý field má své jméno, datový typ a případně další atributy.

Vstupem pro vyhledávání jsou textové řetězce (viz syntax\footnote{\url{http://lucene.apache.org/core/2_9_4/queryparsersyntax.html}}, případně dotazované objekty.

Index je uložen na disku ve formě souborů ve struktuře invertovaného indexu dokumentů~\cite{wiki:invindex}.

Ukázka definice několika field dokumentu ve schématu Solr:

\begin{lstlisting}[language=xml]
<field name="userId" type="int" indexed="true" stored="true" multiValued="true"/>	
<field name="time" type="date" indexed="true" stored="true"/>
<field name="usedInRec" type="boolean" indexed="true" stored="true"/>
\end{lstlisting}

Ukázka reprezentace dokumentu ve výsledku vyhledávání pomocí Apache Solr ve formátu XML:

\begin{lstlisting}[language=xml]
<doc>
   <int name="id">1</int>
   <str name="articleId">http://somedomain.org/somearticle.html</str>
   <str name="articleText">Hello Bob and Alice!</str>
   <int name="group">123</int>
   <bool name="usedInRecommendation">true</bool>
   <date name="time">2009-04-12T20:44:55Z</date>
   <float name="1_rating">0.1</float>
   <float name="2_rating">0.5</float>
   <float name="3_rating">0.5</float>      
   <arr name="userId">
      <int>1</int>
      <int>2</int>
      <int>3</int>
   </arr>
   <long name="_version_">1465487644804775936</long>      
</doc>
\end{lstlisting}

Formu jejich spolupráce lze popsat tak, že Apache Solr poskytuje pro vyhledávání RESTful API, za kterým je skryto a voláno JAVA API knihovny Lucene. Díky tomu je možné pomocí protokolu HTTP komunikovat s Apache Solr z jakékoliv platformy napsané v jakémkoliv programovacím jazyce. 

K integraci Apache Solr s dalšími aplikacemi je možné vybírat ze spousty nástrojů a knihoven\footnote{\url{http://wiki.apache.org/solr/IntegratingSolr}}. Pro účely mé aplikace psané v programovacím jazyce Java jsem zvolil knihovnu \textbf{SolrJ}\footnote{\url{http://wiki.apache.org/solr/Solrj}} s klientským rozhraním pro vyhledávání, přidávání a aktualizaci indexu. 

\subsubsection{Apache Cassandra 2.0}
\textbf{Apache Cassandra 2.0}\footnote{\url{http://cassandra.apache.org}} je open-source distribuovaný DBMS navržený pro obsluhu velkého množství dat. Z hlediska datového modelu je Cassandra jakýmsi hybridem mezi key-value (pod 1 klíčem je uložena 1 hodnota) a column-oriented databázemi. V dokumentaci~\cite{cassdoc} se lze dočíst, že jde o row-oriented databázi.

Základem modelu je \emph{column family} (analogie tabulky v RDBMS), jež je složena z řádků a sloupců. Každý řádek má unikátní identifikátor ve formě klíče – každý řádek obsahuje více sloupců. Sloupce mají jméno, hodnotu a časovou značku. Výhodou proti RDBMS přístupu je to, že rozdílné řádky ze stejné column family nemusí sdílet stejnou množinu sloupců – do jedné nebo více řádek lze v libovolný čas zapsat jakýkoliv sloupec.

Vzhledem k tomu, že jedním z vyzdvihovaných případů užití databáze je uchovávání časových snímků, rozhodl jsem se ji experimentálně zapojit do vytvářeného Recommeng systému. Ještě předtím jsem však detailněji zkoumal možnost použití jiné NoSQL databáze, a to \textbf{Redis}. 

Redis je klasickou key-value databází uchovávající data primárně v paměti. Postupným vývojem se jeho funkcionalita propracovala k tomu, že pod jeden klíč je nyní možné uložit několik datových struktur (např. množiny a asociativní pole). Vzhledem k ukládání dat do paměti disponuje značnou rychlostí, navíc jej lze dle konfigurace nastavit tak, aby se obsah paměti průběžně ukládal na disk pro potřeby snadného obnovení dat v případě pádu aplikace.

Jeho zapojení do aplikace jsem zvažoval ve fázi zkoumání, jakým způsobem bude v adaptibilním systému řešen failover dat. Po následném návrhu datového modelu pro ukládání časových snímků stavu aplikace jsem však sáhl po použití Apache Cassandra jako po lepší z nabízených variant pro budoucí potřeby práce (rozsahové dotazy, vizualizace vývoje systému apod.). 

Velkým benefitem je podpora Cassandra Query Language (CQL), dotazovacího jazyka umožňujícího vytvářet podobné konstrukty, jaké nabízí jazyk SQL. CQL je nyní k dispozici ve verzi 3.1 a s pomocí \textbf{DataStax Java Driver 2.0} mohu snadno manipulovat s databází přímo ze své aplikace. 

\subsection{Ostatní použité technologie}

\subsubsection{Apache Mahout}
\label{mahout}
\textbf{Apache Mahout}\footnote{\url{https://mahout.apache.org}} je knihovna napsaná v programovacím jazyce Java, jež poskytuje implementaci rozličných technik z oblasti strojového učení:

\begin{itemize}
	\item \textbf{shlukování (clustering)} – položky nacházejících se v určitých třídách (například webové stránky či novinové články) jsou organizovány do skupin tak, že položky nacházející se v těchto skupinách jsou si vzájemně podobné
	\item \textbf{klasifikace (classification)} – učení se ze stávajících kategorizací a zařazování neklasifikovaných položek do nejvhodnější kategorie
	\item \textbf{doporučování (recommendation)}
	\item \textbf{často se vyskytující skupiny položek (frequent itemset mining)} – analýza položek v rámci nějaké skupiny (například nákupní košík) a identifikace, které položky se nejčastěji vyskytují pohromadě
\end{itemize}

Pro tyto techniky realizuje příslušné algoritmy jako například kolaborativní filtrování, k-means, náhodné lesy, skryté markovské modely a další. Některé algoritmy jsou připraveny pro běh v distribuovaném módu s využitím paradigmatu Map/Reduce, některé pak v lokálním módu (samotný Mahout je založen na Apache Hadoop, ale lze jej pohodlně využívat i bez něj)~\cite{mahouttut}. Mahout poskytuje též knihovny pro obecné matematické operace (zaměřené hlavně na oblast statistiky) a kolekce\footnote{\url{https://mahout.apache.org/users/basics/mahout-collections.html}}. 

Využít jej pro potřeby své práce jsem se rozhodl poté, co jsem na něj narazil v projektu Mendeley~\ref{mendeley} během zkoumání existujících řešení doporučovacích systémů. 

\subsubsection{Spring Framework}
Při tvorbě každého nového Java projektu od základu je dobré zamyslet se nad možností využít některý z mnoha frameworků a dalších užitečných nástrojů, s jejichž pomocí si lze do značné míry usnadnit proces vývoje. Díky dobrým zkušenostem z dřívějších projektů jsem zvolil open-source framework pro tvorbu moderních enterprise aplikací \textbf{Spring}\footnote{\url{http://projects.spring.io/spring-framework}}. 

Jeho výhodami jsou snadná konfigurovatelnost, podpora dependency injection, rozšiřitelnost a také integrace s jinými frameworky. V mém případě to byla integrace s frameworkem Jersey, kterou jsem využil při implementaci RESTful API.

\subsubsection{Apache Tomcat}
\textbf{Apache Tomcat} je známý open-source webový server a servletový kontejner. Jedná se o oficiální referenční implementaci technologií Java Servlet a Java Server Pages (JSP). Na serveru mohou běžet uživatelské servlety (programy napsané v Javě), které umí zpracovávat požadavky zasílané pomocí HTTP protokolu a tímtéž protokolem na ně odpovídat. Apache Tomcat zde slouží jako zásobník servletů starající se o jejich spouštění, běh, ukončování a podobně.

\subsubsection{Správa závislostí}
Často slýchaným pojmem z úst mnoha vývojářů v programovacím jazyce Java je tzv. \emph{classpath hell}. V podstatě jde o problémy spojené s načítáním programových tříd. V dnešní době existuje spousta nástrojů schopných tento problém efektivně řešit používáním správně projektové struktury, sestavovacích nástrojů a nástrojů pro správu závislostí. Jmenujme například Apache Ant společně s Apache Ivy, Gradle nebo třeba Apache Maven.

\textbf{Apache Maven} jsem použil při implementaci všech komponent aplikace.

\section{Realizace platformy}
\label{chap:impl}

Následující kapitola se zaměřuje na popis programátorských principů, které jsem následoval při práci na realizaci systému, stejně tak popisuje technologie použité při implementaci a vzniklé řešení.

\subsection{Modul adaptibilního systému Recommeng}
\label{sec:impl}

Adaptibilní systém je samostatná \emph{Java Application}.

\subsubsection{Zavedení systému}
Recommeng aplikace se spouští voláním metody \texttt{main()} třídy \textbf{EnsembleApp}. V této metodě je následně volána metoda \texttt{loadConsoleApplication()} abstraktní rodičovské třídy \textbf{EnsembleAppBase}.

Metoda loadConsoleApplication() hraje roli zavaděče aplikace, neboť postupným voláním v sobě obsažených metod zavádí do provozu celý systém. Hlavní ovládací třídou aplikace je třída \textbf{ApplicationBean}, což je Spring bean typu singleton. Jejím prostřednictvím je zavedena vrstva pro obsluhu zpráv i komponenty pro komunikaci s datovým úložištěm. ApplicationBean je mozkem systému a při zavádění aplikace je získána ze Spring aplikačního kontextu.

Ten je možné velice jednoduše konfigurovat pomocí anotací ve třídě \textbf{AppConfig}:

\begin{lstlisting}[language=java]
@Configuration
@EnableScheduling
@ComponentScan(basePackages = {
     "cz.cvut.bouchja1.ensemble.spring"
})
@PropertySource("classpath:application.properties")
public class AppConfig {
...
\end{lstlisting}

Anotace \emph{@EnableScheduling} a \emph{@ComponentScan} využijeme pro pravidelné ukládání stavu aplikace~\ref{task}, anotaci \emph{@PropertySource} zase pro možnosti parametrizace systému~\ref{param}.

\subsubsection{Parametrizace}
\label{param}
Pro účely experimentování se systémem a testování funkčnosti s různě navolenou konfigurací je nutné načítat konfiguraci z editovatelného \emph{properties} souboru. K tomu jsem využil Spring bean \textbf{PropertySourcesPlaceholderConfigurer}.

Konfigurační vlastnosti jsou do souboru \emph{application.properties} přidávány ve formátu:

\begin{lstlisting}
#cassandra or jvm
storage=cassandra
#storage=jvm
   
ensemble.machine.rate=0.5
ensemble.feedback.possitive.best=1.0
\end{lstlisting}

Konkrétní načítání v programu je pak díky použití PropertySourcesPlaceholderConfigurer velice jednoduché:

\begin{lstlisting}[language=java]
this.rate = Double.parseDouble(env.getProperty("ensemble.machine.rate"));
this.possitiveFeedback = Double.parseDouble(env.getProperty("ensemble.feedback.possitive.best"));
\end{lstlisting}

\subsubsection{Pravidelné ukládání časových snímků}
\label{task}
Pravidelné ukládání časových snímků jsem realizoval démonem (\emph{cron}). Četnost jeho spouštění je možné volit přes parametr~\ref{param} v konfiguračním souboru aplikace. K tomuto účelu jsem vytvořil třídu \textbf{ScheduledJob} s veřejnou metodou \emph{run()}. Na metodu bylo též nutné aplikovat anotaci s parametrem \emph{@Scheduled(cron = "\$\{scheduling.job.cron\}")}. Tato metoda je tedy automaticky volána systémem, na kterém aplikace běží. 

Po automatickém spuštění této metody dojde k vyvolání metody \emph{saveCurrentState()} třídy ApplicationBean, která zprostředkuje persistenci aktuálního stavu aplikace (tedy všech běžících bayesovských strategií), který je v té době v paměti, do databáze.

Samozřejmě za předpokladu, že je použití databáze v konfiguračním souboru nastaveno. V opačném případě by tovární metoda třídy \textbf{StorageFactory} zvolila k použití jinou formu práce s daty.

\begin{lstlisting}[language=java]
public static IStorage getStorage(Environment env) {
    switch (env.getProperty("storage")) {
        case "cassandra" : 
            return new CassandraStorage(env.getProperty("cassandra.host"), env.getProperty("cassandra.keyspace"));                
        default : 
            return new JvmStorage();
    }
}
\end{lstlisting}

Tento přístup vede k rozšiřitelnosti o další typy databází, které by mohl systém v budoucnu podporovat. 

\begin{lstlisting}[language=java]
@Scope("singleton")
public class ApplicationBean {
   ...
   private IStorage storage;
   ...
   
   public void saveCurrentState() {
       try {
           storage.saveCurrentState(strategies);
       } catch (NullPointerException ex) {
           logger.error("Application is not initialized yet.", ex);
       }
   }
   ...
}   
\end{lstlisting}

\subsubsection{Databázové úložiště Cassandra}
Úložiště je realizováno třídou \textbf{CassandraStorage}. Během jejího zavádění do systému při startu aplikace jsou v konstruktoru volány dvě metody – \emph{connect()} a \emph{createSchema()}. V prvním případě dochází ke spojení s databázovým klastrem, pomocí kterého je následně získána \emph{session}.

Pomocí session a její metody \emph{execute()} lze vykonávat jednotlivé dotazy. 

Použita je hned v metodě createSchema(), která je zodpovědná za vytvoření datového modelu navrženého pro systém Recommeng.

Ukázka vytvoření keyspace pro všechny column families aplikace:

\begin{lstlisting}[language=java]
private void createSchema() {        
    session.execute("CREATE KEYSPACE IF NOT EXISTS " + keyspace + " WITH replication "
            + "= {'class':'SimpleStrategy', 'replication_factor':3};");
\end{lstlisting}

Column families jsem pro účely aplikace vytvořil dvě – \emph{collection} a \emph{algorithm}.

Druhá column family má dělený klíč řádku:

\begin{verbatim}
PRIMARY KEY ((collection_id, algorithm_id), event_time)
\end{verbatim}

a reverzní řazení založené na časové značce indikující dobu zápisu do databáze:

\begin{verbatim}
WITH CLUSTERING ORDER BY (event_time DESC)
\end{verbatim}

Třída pak implementuje několik metod svého rozhraní IStorage pro uložení aktuálního stavu aplikace, načtení poslední známé konfigurace a vytvoření kolekce banditů. Při realizaci funkcionality metod je bohatě využíváno možností, které nabízí DataStax driver pomocí CQL, například tvorba předpřipravených dotazů konstrukcí \textbf{PreparedStatement}. 

Následuje příklad ukládání aktuálního stavu z paměti systému do databáze.

\begin{lstlisting}[language=java]
@Override
public void saveCurrentState(List<BayesianStrategy> strategies) {
    for (BayesianStrategy strategy : strategies) {
        List<Bandit> bandits = strategy.getBanditsMachine().getBanditList();
        if (bandits.size() > 0) {
            PreparedStatement statement = session.prepare(
                    "INSERT INTO " + keyspace + ".algorithm "
                    + "(collection_id, algorithm_id, event_time, probability_in_time, trials_rate, successes_rate) "
                    + "VALUES (?, ?, ?, ?, ?, ?);");

        ...

            for (Bandit b : bandits) {
                BoundStatement boundStatement = new BoundStatement(statement);
                session.execute(boundStatement.bind(
                        strategy.getCollectionId(),
                        b.getName(),
                        actualDate,
                        b.getProbability(),
                        b.getTrials(),
                        b.getSuccesses()));
                ...
        ...
}
\end{lstlisting}

\subsection{Vrstva pro obsluhu zpráv}
\label{sub:messvrs}
Následující text popisuje postup, jakým jsem realizoval vrstvu pro obsluhu zpráv pomocí síťové knihovny ZeroMQ.

Většinová funkcionalita je řešena třídou \texttt{MultiThreadServer} (obsahující též vnitřní třídu \textbf{WorkerThread}) z balíčku projektu Ensemble:

\begin{verbatim}
   cz.cvut.fit.bouchja1.ensemble.socket
\end{verbatim}

Postup by se dal shrnout do tří kroků:

\begin{enumerate}
	\item rozhodnutí o komunikačním protokolu
	\item definice síťové infrastruktury
	\item realizace vzoru pro zasílání zpráv REQ/REP
\end{enumerate}

\subsubsection{Rozhodnutí o komunikačním protokolu}
\label{subsub:kompr}
V prvním kroku bylo nutné rozhodnout o tom, jakým způsobem bude probíhat přenos dat směrem k Recommeng systému a naopak. Ze čtyř protokolů, jimiž disponuje ZeroMQ, jsem pro přenos dat zvolil síťový protokol \textbf{TCP}, a to z toho důvodu, že dle návrhu architektury by měl adaptibilní systém naslouchat na serveru a uživatelé s ním mít možnost navazovat spojení zvenčí mimo server.

Mezi komunikujícími klienty a Recommeng aplikací na serveru jsou vytvářena jednotlivá spojení a data jsou z jednoho koncového bodu na druhý přenášena ve formě bajtů.

Díky ZeroMQ API stačí připravit kontext a socket a metodě \texttt{bind()} nastavit adresu serveru s příslušným portem. Sama metoda se pak postará o zbylou práci (vytvoření endpointu pro příjem jednotlivých spojení a navázání na socket).

\begin{lstlisting}[language=java]
ZMQ.Context context = ZMQ.context(IO_THREADS_COUNT);
// Socket to talk to clients
ZMQ.Socket clients = context.socket(ZMQ.ROUTER);
clients.bind("tcp://" + host + ":" + port);
\end{lstlisting}

\subsubsection{Definice síťové infrastruktury}
\label{subsub:queue}
Propojení jednotlivých síťových komponent vychází z nativní povahy architektury Klient-Server. Server zastává roli stabilnější komponenty v síti, bude tedy přijímat spojení (viz ukázka s metodou \texttt{bind()} výše). Zároveň jsem mezi server a připojující se klienty umístil prostředníka v podobě \emph{fronty}, jehož úkolem je jak obsluha všech žádostí na server, tak i odpovědí zpět klientům.

\begin{lstlisting}[language=java]
ZMQQueue queue = new ZMQQueue(context, clients, workers);
\end{lstlisting}

V případě více připojených klientů ZeroMQ automaticky obstarává obsluhu všech příchozích žádostí. 

\subsubsection{Realizace vzoru pro zasílání zpráv REQ/REP}
Pro zasílání zpráv jsem zvolil obousměrně komunikující vzor \emph{Request Reply}. Toto paradigma je známé z většiny serverových typů\footnote{HTTP, POP či IMAP}. Klient používá vlastní socket typu \textbf{ZMQ.REQ} k inicializaci žádosti, kterou následně odesílá na server. Server též užívá vlastního socketu \textbf{ZMQ.REP} ke čtení příchozí žádosti, po které zasílá odpověď. 

Problém je, že vzor Request-Reply toho v základní variantě mnoho neumožňuje, proto bylo nutné umožnit asynchronní komunikaci implementací rozšíření v podobě socketů \textbf{ROUTER} a \textbf{DEALER} (dříve nazývány jako XREP a XREQ). 

Řešení spočívá ve vytvoření více vláken (\emph{workers}), kdy každé vlákno disponuje jedním REP socketem. Za tímto účelem je nutné vytvořit socket typu DEALER, kterému přiřadíme komunikační protokol \emph{inproc://}. Poté, co DEALER obdrží zprávu, přenese ji na jeden z REP socketů. Přitom sleduje, které REP sockety jsou zaneprázdněny, a které mohou naopak zprávu přijmout. Jakmile tento vybraný REP socket zpracuje zprávu, předá ji zpět a DEALER tuto zprávu přepošle tak, jak ji obdržel od socketu.

\begin{lstlisting}[language=java]
// Socket to talk to workers
ZMQ.Socket workers = context.socket(ZMQ.DEALER);
workers.bind("inproc://workers");
\end{lstlisting}

Kvůli podpoře více TCP spojení utvářených vůči serveru je nutné předřadit před socket typu DEALER ještě další typ socketu, kterým je ROUTER (byl vidět již v ukázce~\ref{subsub:kompr}). 

ROUTER přiřazuje vnitřní identifikátor každému k němu se připojujícímu socketu, následně obdrženou zprávu předává dál i s připojenými metadaty (identifikátor socketu) a poté, co zprávu obdrží zpět, ihned ji předává správnému REQ socketu, kterého identifikuje opět díky identifikátoru uchovávaném v metadatech.

Toto chování je umožněno díky vestavěné funkcionalitě ZMQQueue (viz příklad~\ref{subsub:queue}). Všechny zprávy, které přijme ROUTER, jsou zaslány na DEALER a naopak. Model této komunikace ilustruje obrázek~\ref{fig:mtserver}.

\begin{figure}\centering
	\includegraphics[width=0.8\textwidth]{obr/multithreadingServer.png}
 	\caption[Vícevláknový server s využitím ROUTER a DEALER.]{Vícevláknový server s využitím ROUTER a DEALER. Zdroj: \cite{mtserver}}\label{fig:mtserver}
\end{figure}	

\begin{lstlisting}[language=java]
//Forwards messages from router to dealer and vice versa.
new Thread(queue).start();
\end{lstlisting}

Vyvoláním metody \texttt{start()} dojde k uzamknutí aktuálního vlákna (důvod, proč pro frontu existuje vlastní vlákno). To je jedna z pokročilých vlastností ZeroMQ – pro vývoj vícevláknových aplikací nejsou potřeba žádné mutexy, zámky, ani jakékoliv další formy komunikace kromě zpráv zasílaných napříč ZeroMQ sockety~\cite{mtserver}.

Na začátku procesu (při spuštění aplikace) je vytvořen ZeroMQ kontext (viz \ref{subsub:kompr}) a ten je předán všem vláknům, která jsou připravena pro komunikaci protokolem inproc:

\begin{lstlisting}[language=java]
// Launch worker threads
for (int i = 0; i < threads.length; i++) {
   threads[i] = new MultiThreadServer.WorkerThread(
      i, context, api, new RequestHandlerJson()
   );
   threads[i].start();
}
\end{lstlisting}

Vláknům je parametrem předána instance třídy \textbf{RequestHandlerJson}, takže jsou schopny obsluhovat příchozí žádosti ve formátu JSON. Jedná se o implementaci rozhraní \textbf{RequestHandler} s jednou definovanou metodou pro obsluhu zpráv. Tento typ přijímají ve svém konstruktoru i pracovní vlákna. Řešení je tedy postaveno tak, aby bylo snadno rozšiřitelné pro jakýkoliv jiný formát komunikace, klidně vlastní.

\begin{lstlisting}[language=java]
public interface RequestHandler {
   public Operation handleMessage(byte[] message)
      throws MessageFormatException;
}
\end{lstlisting}

\subsubsection{Technika zasílání zpráv a WorkerThread}
O několik řádku výše bylo vysvětleno, jakým způsobem jsou na serveru zpracovány příchozí žádosti. Nyní již víme, že tuto funkcionalitu mají na starosti pracovní vlákna typu \textbf{WorkerThread}.

Každý \emph{worker} v sobě udržuje kontext komunikace a pokud je na vstupu validní žádost, pro její zpracování je vyvolána příslušná operace rozhraní systému Recommeng. Sestavená odpověď je zaslána zpátky klientovi.

Třída WorkerThread je vláknová; kromě konstruktoru obsahuje pouze jednu metodu \texttt{run()}. Právě tato metoda má na svědomí veškerou obsluhu žádosti zahrnující zpracování zprávy, volbu správné operace na rozhraní systému a po zpracování pak zaslání odpovědi zpátky k žádajícímu klientovi.

V praxi to vypadá tak, že pokud je dané pracovní vlákno aktivní, čte příchozí žádost:

\begin{lstlisting}[language=java]
@Override
public void run() {
   ZMQ.Socket receiver = context.socket(ZMQ.REP);
   receiver.connect("inproc://workers");
   while (!Thread.currentThread().isInterrupted()) {
      byte[] request = receiver.recv(0);
...
\end{lstlisting}

Po přečtení žádosti následuje zpracování:

%\begin{verbatim}
\begin{lstlisting}[language=java]
try {
   Operation op = requestHandler.handleMessage(request);
   if (op.validateOperation()) {
      try {
         Reply reply = op.executeOperation(api);
         responseHandler.setReply(reply);
      } catch (Exception ex) {
         ex.printStackTrace();
      }
   } else {
      responseHandler.createErrorReply(op.getErrorMessage());
   }

   try {
      int sleepTime = (threadNo % 2 == 0) ? 100 : 200;
      // Handle work, by sleeping for some time
      Thread.sleep(sleepTime);
   } catch (InterruptedException e) {
      e.printStackTrace();
      Thread.currentThread().interrupt();
   }
} catch (MessageFormatException | IOException ex) {
   responseHandler.createErrorReply(ex.getMessage());
}
\end{lstlisting}

Výsledkem zpracování zprávy je tedy operace realizována návrhovým vzorem Command. \textbf{Operation} je rozhraní deklarující metody pro validaci operace (\texttt{validateOperation()}) a její vykonání (\texttt{executeOperation()}). Každá třída implementující toto rozhraní je pak konkrétní operací, která volá rozhraní systému Recommeng. 

Všechny typy podporovaných operací se nacházejí v aplikaci Ensemble v balíčku:

\begin{verbatim}
   cz.cvut.fit.bouchja1.ensemble.operation
\end{verbatim}

Jedná se o třídy splňující funkcionalitu dle funkčních požadavků~\ref{sec:req}:

\begin{itemize}
	\item \texttt{OperationCreateBanditCollection}
	\item \texttt{OperationDetectBestBandit}
	\item \texttt{OperationDetectBestBandit}
	\item \texttt{OperationDetectBestBandit}			
\end{itemize}

Výsledkem vykonání operace je vždy odpověď (třída \textbf{Reply} s atributy pro stavový kód a tělo zprávy), která je pomocí třídy \textbf{ResponseHandlerDefault} prezentována zpět klientovi.

\subsection{Adaptibilní systém Recommeng}

\subsubsection{API}
API systému Recommeng reprezentuje interface \textbf{EnsembleApiFacade}. Nejdůležitějšími metodami jsou metody:

\begin{itemize}
	\item \texttt{createBanditSet(String banditSetId, Set<String> banditIds)}
	\item \texttt{detectBestBandit(String banditCollectionId, String filter)}
	\item \texttt{selectBandit(String banditCollectionId, String banditId)}
	\item \texttt{calculateFeedback(String banditCollectionId, String banditId, String feedbackValue)}			
\end{itemize}

Tyto metody jsou volány prostřednictvím operací z vrstvy pro obsluhu zpráv~\ref{sub:messvrs}. Metody jsou přímo napojeny na bayesovskou strategii, což je hlavní ovládací prvek Recommeng systému.

\subsubsection{Bayesian Bandits}

TODOOOOO někam zpětná vazba

Strategii řeší tří třídy umístěné v balíčku:

\begin{verbatim}
   cz.cvut.fit.bouchja1.ensemble.bandits
\end{verbatim}

\begin{description}
	\item[Bandit] je třída reprezentující jednoho konkrétní banditu. Každý bandita má svůj identifikátor a atributy pro zaznamenávání výher a pokusů během jednotlivých her.
	\item[BanditsMachine] je třída reprezentující jeden herní automat. Tento automat obsahuje seznam banditů a číselné parametry pro výpočty zpětné vazby a míry učení. V podstatě se jedná o konfiguraci, pomocí které je automat naprogramován. Tato konfigurace se nastavuje ve vnějším soubor (viz~\ref{param}).
	\item[BayesianStrategy]	je třída reprezentující online učící strategii k řešení strategie Multi-Armed Bandit~\ref{sub:mabandit}. Vzhledem k tomu, že je pro kombinování možné vytvářet více kolekcí s bandity, v systému může nezávisle na sobě fungovat více bayesovských strategií. 
	
	Každá z nich je pak reprezentována dle identifikátoru kolekce, každá má přiřazen svůj vlastní herní automat a logiku algoritmu.  
	
	Nejdůležitější metodou této třídy je metoda \texttt{sampleBandits(String banditCollectionId)} starající se jednak o výběr z prior pravděpodobností distribucí banditů nacházejících se v kolekci s identifikátorem \emph{banditCollectionId}, a následně o volbu nejlepšího z banditů. 
	
\begin{lstlisting}[language=java]
public Bandit sampleBandits(String banditCollectionId) {
    //sample from the bandits's priors, and select the largest sample
    for (int j = 0; j < banditsMachine.getBanditList().size(); j++) {
        BetaDistribution beta = new BetaDistribution(1 + banditsMachine.getBanditAtIndex(j).getSuccesses(), 1 + banditsMachine.getBanditAtIndex(j).getTrials() - banditsMachine.getBanditAtIndex(j).getSuccesses());

        double inverseDistribution = beta.inverseCumulativeProbability(Math.random());
        roundInverseDistributions.add(inverseDistribution);
    }

    int banditIndexChoice = MathUtil.argmax(roundInverseDistributions);

    roundInverseDistributions.clear();

    return banditsMachine.getBanditAtIndex(banditIndexChoice);
}
\end{lstlisting}	
	
\end{description}

\subsection{Modul pro RESTful API}
\label{sub:restapi}

RESTful API je realizováno jako \emph{Java Web Application}.

Důležitou roli v modulu hraje přítomnost a správná konfigurace tzv. \emph{Web Application Deployment Descriptor} (soubor \textbf{/WEB-INF/web.xml}). V tomto souboru je definováno vše, co by měl server, na kterém aplikace poběží, o aplikaci vědět (informace o příslušných servletech, filtrech apod.).

Pro potřeby modulu RESTful API jsem v tomto souboru definoval \emph{listener\footnote{Listener je aplikace, jež vyčkává na vznik nějaké události. Jakmile událost nastane, listener zareaguje a převezme její řízení.} pro Spring}. Dále \emph{servlet pro Jersey}, jemuž jsem parametrem předal třídu \textbf{RecommengApplication}, a nastavil příslušné mapování servletu na specifickou URL.

\begin{lstlisting}[language=java]
<servlet>
    <servlet-name>jersey-serlvet</servlet-name>
    <servlet-class>
        org.glassfish.jersey.servlet.ServletContainer
    </servlet-class>
    <init-param>
        <param-name>javax.ws.rs.Application</param-name>
        <param-value>cz.cvut.fit.bouchja1.mi_dip.rest.client.service.RecommengApplication</param-value>            
    </init-param>        
    <load-on-startup>1</load-on-startup>
</servlet>

<servlet-mapping>
    <servlet-name>jersey-serlvet</servlet-name>
    <url-pattern>/recommeng/*</url-pattern>
</servlet-mapping>
\end{lstlisting}

Pomocí třídy RecommengApplication, rozšiřující třídu ResourceConfig frameworku Jersey, jsem zaregistroval všechny aplikační komponenty, které budou použity JAX-RS aplikací, tedy vytvářeným RESTful API.

\begin{lstlisting}[language=java]
public RecommengApplication(){
    register(RequestContextFilter.class);
    register(AlgorithmEndpoint.class);
    register(CoresEndpoint.class);
    register(EnsembleEndpoint.class);
    register(JacksonFeature.class);        
}
\end{lstlisting}

Třída registruje následující komponenty:

\begin{itemize}
	\item 
\begin{lstlisting}[language=java]	
org.glassfish.jersey.server.spring.scope.RequestContextFilter
\end{lstlisting}
	
	Jedná se o Spring filter, který poskytuje propojení mezi JAX-RS a Spring žádostmi.
	
	\item
\begin{lstlisting}[language=java]	
cz.cvut.fit.bouchja1.mi_dip.rest.client.endpoint.AlgorithmEndpoint
\end{lstlisting}

	\item
\begin{lstlisting}[language=java]	
cz.cvut.fit.bouchja1.mi_dip.rest.client.endpoint.CoresEndpoint
\end{lstlisting}

	\item
\begin{lstlisting}[language=java]	
cz.cvut.fit.bouchja1.mi_dip.rest.client.endpoint.EnsembleEndpoint
\end{lstlisting}
	
	Tyto tři třídy jsou služby REST API. 
	\item
\begin{lstlisting}[language=java]		
org.glassfish.jersey.jackson.JacksonFeature	
\end{lstlisting}
	
	Registruje Jackson JSON poskytovatele pro zpracování příchozích dat ve formátu JSON.
\end{itemize}

Nakonec jsem definoval filtr \emph{CharacterEncodingFilter} s UTF-8 kódováním pro všechny URL splňující vzor:

\begin{lstlisting}[language=java]
<filter-mapping>
    <filter-name>CharacterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>    
\end{lstlisting}

\subsubsection{Realizace endpointů}
\label{sec:endpoints}
Třídy z balíčku:

\begin{verbatim}
cz.cvut.fit.bouchja1.mi_dip.rest.client.endpoint
\end{verbatim}

jsou služby typu REST obsluhující všechny žádosti směřující na jimi mapované zdroje. Programově má každá tato třída anotaci definující její relativní URI cestu. V případě třídy \textbf{CoresEndpoint} vypadá definice následovně:

\begin{lstlisting}[language=java]
@Component
@Path(EnsembleEndpoint.ENDPOINT_PATH)
public class CoresEndpoint {
    
    public static final String ENDPOINT_PATH = "/cores";
    public static final String USER_ARTICLE_PATH = "/{coreId}/document";

	private CoresEndpointHelper coresEndpointHelper; 		
    ...
\end{lstlisting}

Anotace \emph{@Path} v tomto případě značí, že třída se bude nacházet na URI \emph{/recommeng/cores}.

Jedna z jejích služeb umožňující vytvářet či aktualizovat informace o položkách v indexu zasíláním žádostí na URI zdroje \emph{/recommeng/cores/{coreId}/document} je definována takto:

\begin{lstlisting}[language=java]
@Path(USER_ARTICLE_PATH)
@Consumes({MediaType.APPLICATION_JSON})
@Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
@POST
public Response insertUpdateUserArticle(@PathParam("coreId") String coreId, UserArticleDocument userArticle) {
    return coresEndpointHelper.putUserArticle(coreId, userArticle);
}    
\end{lstlisting}

O samotné reprezentaci zdroje referuje příslušná podpodsekce~\ref{subsub:resource}.

Provádění má na starosti v tomto případě \textbf{CoresEndpointHelper}. Ostatní služby mají též své helpery – třídy pomáhající jim v obsluze žádosti zodpovědné za vytváření odpovědí, které rozšiřují rodičovskou třídu \textbf{CommonEndpointHelper} implementující rozhraní \textbf{EndpointHelper}.

Rozhraní deklaruje více metod souvisejících s odpovědí, například metody pro vytvoření odpovědi dle typu návratového kódu a sestavení odpovědi.

\begin{lstlisting}[language=java]
public Response getNotFoundResponse(String message);
public Response build(ResponseBuilder builder, String message);
\end{lstlisting}

Proces tvorby odpovědi pak vypadá tak, že konkrétní helper volá ve své metodě službu zajišťující komunikaci s indexem. V případě metody \emph{putUserArticle(String coreId, UserArticleDocument userArticle)} pro vkládání vztahu uživatel-článek do indexu je po provedení příslušných kontrol, kterými jsou validace vstupních dat a podobně, vytvořena odpověď.

\begin{lstlisting}[language=java]
public Response putUserArticle(String coreId, UserArticleDocument userArticle) {
    Response resp;
    if (coreSolrService.getSolrService().isServerCoreFromPool(coreId)) {
        String message = UserArticleValidator.validateUserArticle(userArticle);
        if ("success".equals(message)) {
            try {
                coreSolrService.putUserArticle(coreId, userArticle);
                resp = getOkResponse();
            } catch (SolrServerException ex) {
			...
        } else {
            resp = getBadRequestResponse(message);
        }
    } else {
        ...

    return resp;
}
\end{lstlisting}

Helper tedy volá dle výsledků programu jednu z metod své rodičovské třídy (například \emph{getBadRequestResponse(message)}) s příslušnou zprávou v parametru. Metodou \emph{build(ResponseBuilder builder, String message)} je pak vytvářena samotná odpověď.

\begin{lstlisting}[language=java]
@Override
public Response getNotFoundResponse(String message) {
    return build(Response.status(Response.Status.NOT_FOUND), message);
}    

@Override
public Response build(ResponseBuilder builder, String message) {
    return builder.entity(message).build();
}
\end{lstlisting}

\subsubsection{Reprezentace zdrojů}
Zdroje jsou jedním ze stěžejních konceptů architektury REST. Kromě toho, že jsou adresovány příslušnými globálními identifikátory (v HTTP realizaci např. pomocí URI), mají též jednu nebo více reprezentací, ve které jsou vystaveny okolnímu světu, a pomocí které je možné s těmito zdroji manipulovat. 

V modulu pro RESTful API reprezentuji zdroje jako třídy v Javě. Například při tvorbě zdroje \emph{/recommeng/cores/{coreId}/document} je vytvářena třída \textbf{UserArticleDocument}. 

\begin{lstlisting}[language=java]
@XmlRootElement
public class UserArticleDocument implements Serializable {       
    
    private static final long serialVersionUID = -8039686696076337053L;    
    private String articleId;
    private String articleText;
    private String group;
    private int userId;    
    private Date time;    
    private double userRating;
    ...
\end{lstlisting}

Reprezentace tohoto zdroje ve formátu JSON by pak mohla vypadat například takto:

\begin{lstlisting}
{
    "articleId":"http://somedomain.org/somearticle.html",
    "articleText":"Hello Bob and Alice!",
    "group":"123",
    "userId":42,
    "time":"2009-04-12T20:44:55Z",
    "userRating":5.0
}
\end{lstlisting}

\subsubsection{Komunikace s Recommeng systémem}
\label{sec:restrec}
Vytvořil jsem též službu \textbf{EnsembleEndpoint} pro komunikaci s Recommeng systémem. Rozdíl oproti zbylým dvou službám (AlgorithmEndpoint a CoreEndpoint) je v rozdílném chování a funkčnosti její pomocné třídy \textbf{EnsembleZeroMqHelper}.

Tato služba, ač běžící jako součást serverové aplikace, hraje vůči Recommeng systému roli klientskou. Pro vnější uživatele zastává tradiční roli serveru.

EnsembleZeroMqHelper zpracovává příchozí žádosti od uživatelů prostřednictvím RESTful API a následně tyto žádosti transformuje do formátu JSON dle stanoveného schématu imitujícího chování HTTP protokolu. Poté je pomocníkem vytvořen klientský socket a předřazená klientská žádost je odeslána do systému. Pomocník pak vyčkává na odpověď. Poté, co ji obdrží a zpracuje do formátu HTTP odpovědi, ji vrací zpět žádajícímu klientovi. 

Ukázka komunikace služby EnsembleEndpoint. Stejně jako v předchozích případech předává řízení na svou pomocnou třídu.

\begin{lstlisting}[language=java]
@Component
@Path(EnsembleEndpoint.ENDPOINT_PATH)
public class EnsembleEndpoint {
    
    ...
    @Autowired
    private EnsembleZeroMqHelper ensembleZeroMqHelper;
    ...
	
    @Path(COLLECTION_PATH + COLLECTION_ID)
    @GET   
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML})
    public Response getBanditCollection(@PathParam(value="collectionId") String collectionId, @QueryParam(value = "filter") String filter) {
        return ensembleZeroMqHelper.filterBanditCollection(collectionId, filter);
    }
    
    ...
}
\end{lstlisting}

Její funkcionalita už je ale oproti předchozím případům odlišná, především kvůli nutnosti vystavět žádost do formátu volání vzdálených procedur Recommeng systému a podobným způsobem zpracovat i odpověď.

\begin{lstlisting}[language=java]
public Response filterBanditCollection(String collectionId, String filter) {
    Response resp = null;
    connect(); // connecting to socket

    SmileRequest req = new SmileRequest();
    req.setMethod("GET");
	...
    req.setPath("/ensemble/services/collection/" + collectionId + "?filter=" + filter);

    try {
        String json = new ObjectMapper().writeValueAsString(req);
		...
        //encode data
        byte[] smileData = mapper.writeValueAsBytes(req);
        requester.send(smileData, 0);
        //Block until we receive a response
        byte[] reply = requester.recv(0);
        SmileResponse result = mapper.readValue(reply, SmileResponse.class);
        json = new ObjectMapper().writeValueAsString(result);
        logger.info(json);
        resp = buildResponse(result);            
     	...
     }
    return resp;        
}    
\end{lstlisting}

\subsubsection{Komunikace sady algoritmů pro doporučování}
\label{sec:algcom}
Doporučení je vyvoláno klientskou žádostí na rozhraní reprezentované třídou \textbf{AlgorithmEndpoint}. 

Služby využívají pro zpracování žádostí a vytváření odpovědí pomocnou třídu \textbf{AlgorithmEndpointHelper} (podobně jako~\ref{sec:restrec}). Tato třída v sobě navíc udržuje odkaz v podobě instance třídy \textbf{AlgorithmSolrService}, která svými metodami implementuje funkcionalitu jednotlivých algoritmů pro doporučování v textu.

\emph{Pozn.} Následující text se týká též tříd \textbf{CoresEndpoint} a \textbf{CoresEndpointHelper}. Ke komunikaci se Solr je použito instance třídy \textbf{CoreSolrService}, která též obsahuje komponentu \textbf{SolrService} zajišťující obsluhu spojení.


\begin{description}
	\item[Třída SolrService]
	
Třída je též prostředníkem mezi REST API a Apache Solr díky komponentě \textbf{SolrService}, která funguje především jako pool instancí serverových spojení pro různá jádra Solr. Vytvoření takového poolu bylo nutností kvůli možnosti znovu použít již vytvořené instance třídy \textbf{HttpSolrServer}.

HttpSolrServer je thread-safe\footnote{Programové operace jsou prováděny správně i tehdy, kdy jsou prováděny více vlákny současně.} a pokud jej použijeme k vytvoření nové instance s URL některého z jader Solr v parametru, je nutné tuto instanci znovu použít pro všechny žádosti směřující na danou URL~\cite{solrj}. 

V opačném případě, kdy jsou instance vytvářeny bez jakéhokoliv rozmyslu a strategie, hrozí \emph{leak} připojení~\cite{metawerx}.

Validní jádra Solr pro připojení do poolu se nastavují v souboru aplikačního kontextu pro Spring:

\begin{lstlisting}[language=xml]
<bean id="solrService" class="cz.cvut.fit.bouchja1.mi_dip.rest.client.solr.SolrService">
    <property name="serverUrl" value="http://localhost:8089/solr/"/>
    <property name="validSolrCores">
        <set>
            <value>mi_dip_core1</value>
            <value>mi_dip_core2</value>
        </set>
    </property>        
</bean>  
\end{lstlisting}

SolrService je \emph{singleton scope} komponenta s metodou \emph{createValidSolrServers()}, jež je anotována jako \emph{@PostConstruct}. Jejími atributy jsou:

\begin{lstlisting}[language=java]
private String serverUrl;
private Map<String, HttpSolrServer> validServers = new HashMap<String, HttpSolrServer>();
private Set<String> validSolrCores;
\end{lstlisting}

Metoda s anotací @PostConstruct je vyvolána ještě před samotným vytvořením instance třídy. Účelem je naplnění poolu příslušnými validními instancemi spojení.

\begin{lstlisting}[language=java]
Iterator<String> validCores = validSolrCores.iterator();
while (validCores.hasNext()) {
    String core = validCores.next();
    validServers.put(core, new HttpSolrServer(serverUrl + core));
}
\end{lstlisting}

Kdykoliv pak v metodách třídy AlgorithmSolrService navazujeme spojení se serverem, dle zadaného identifikátoru jádra (coreId) se pokoušíme získat instanci z poolu, který má parametry \emph{HashMap<String, HttpSolrServer>}. 

\begin{lstlisting}[language=java]
HttpSolrServer server = solrService.getServerFromPool(coreId);
\end{lstlisting}
	
\end{description}

\subsection{Implementace základních algoritmů pro doporučování obsahu}
\label{sec:alg}

\subsubsection{Algoritmus náhodného výběru}

\subsubsection{Algoritmus výběru dle nejnovějších položek}

\subsubsection{Algoritmus výběru nejlépe hodnocených položek}

\subsubsection{Algoritmus výběru dle podobnosti obsahu}

\subsubsection{Algoritmus kolaborativního filtrování}

\subsection{Apache Solr jako úložiště dokumentů}

\chapter{Experimentální část}
\label{chap:tests}

Jednou z mnoha výzev pro někoho, kdo se snaží vybudovat doporučovací systém, je to, že je velice těžké dopředu říct, zda budou naše předpovědi dost přesné. Alespoň do té doby, dokud je nezačneme dělat a nebudeme pozorovat, jak často naši uživatelé přijímají naše návrhy. Je zde obrovský prostor možností (možných metod), z čeho vybírat. 

kecy o testování
\section{Testování různých způsobů chování}
viz jak jarda vymyslel těch zhruba 5 příkladů, co mohou nastat
\section{Experimenty}

\url{http://contest.plista.com/wiki/example}
	\subsection{Vyhodnocovací technologie}	
	Výpočty. kvůli kombinování budeme počítat s floaty
	

\section{Zhodnocení aplikace}
Slovní zhodnocení
\section{Budoucí práce}
bude li nějaká

\begin{conclusion}
	%sem napište závěr Vaší práce
\end{conclusion}

\bibliographystyle{csn690}
\bibliography{mybibliographyfile}

\appendix

\chapter{Seznam použitých zkratek}
% \printglossaries
\begin{description}
	\item[IDC] 
	\item[CTO]
	\item[MIT]	
	\item[ACM] Association for Computing Machinery	
	\item[ICWSM]	
	\item[ICML]	
	\item[IBM]	
	\item[REST]	
	\item[API]							
	\item[TCP]
	\item[DBMS]
	\item[NoSQL]
	\item[MQ]
	\item[JVM]
	\item[JSON]
	\item[URL]
	\item[ORP]
	\item[HTTP]
\end{description}


% % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% % Tuto kapitolu z výsledné práce ODSTRAŇTE.
% % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% 
% \chapter{Návod k~použití této šablony}
% 
% Tento dokument slouží jako základ pro napsání závěrečné práce na Fakultě informačních technologií ČVUT v~Praze.
% 
% \section{Výběr základu}
% 
% Vyberte si šablonu podle druhu práce (bakalářská, diplomová), jazyka (čeština, angličtina) a kódování (ASCII, \mbox{UTF-8}, \mbox{ISO-8859-2} neboli latin2 a nebo \mbox{Windows-1250}). 
% 
% V~české variantě naleznete šablony v~souborech pojmenovaných ve formátu práce\_kódování.tex. Typ může být:
% \begin{description}
% 	\item[BP] bakalářská práce,
% 	\item[DP] diplomová (magisterská) práce.
% \end{description}
% Kódování, ve kterém chcete psát, může být:
% \begin{description}
% 	\item[UTF-8] kódování Unicode,
% 	\item[ISO-8859-2] latin2,
% 	\item[Windows-1250] znaková sada 1250 Windows.
% \end{description}
% V~případě nejistoty ohledně kódování doporučujeme následující postup:
% \begin{enumerate}
% 	\item Otevřete šablony pro kódování UTF-8 v~editoru prostého textu, který chcete pro psaní práce použít -- pokud můžete texty s~diakritikou normálně přečíst, použijte tuto šablonu.
% 	\item V~opačném případě postupujte dále podle toho, jaký operační systém používáte:
% 	\begin{itemize}
% 		\item v~případě Windows použijte šablonu pro kódování \mbox{Windows-1250},
% 		\item jinak zkuste použít šablonu pro kódování \mbox{ISO-8859-2}.
% 	\end{itemize}
% \end{enumerate}
% 
% 
% V~anglické variantě jsou šablony pojmenované podle typu práce, možnosti jsou:
% \begin{description}
% 	\item[bachelors] bakalářská práce,
% 	\item[masters] diplomová (magisterská) práce.
% \end{description}
% 
% \section{Použití šablony}
% 
% Šablona je určena pro zpracování systémem \LaTeXe{}. Text je možné psát v~textovém editoru jako prostý text, lze však také využít specializovaný editor pro \LaTeX{}, např. Kile.
% 
% Pro získání tisknutelného výstupu z~takto vytvořeného souboru použijte příkaz \verb|pdflatex|, kterému předáte cestu k~souboru jako parametr. Vhodný editor pro \LaTeX{} toto udělá za Vás. \verb|pdfcslatex| ani \verb|cslatex| \emph{nebudou} s~těmito šablonami fungovat.
% 
% Více informací o~použití systému \LaTeX{} najdete např. v~\cite{wikilatex}.
% 
% \subsection{Typografie}
% 
% Při psaní dodržujte typografické konvence zvoleného jazyka. České \uv{uvozovky} zapisujte použitím příkazu \verb|\uv|, kterému v~parametru předáte text, jenž má být v~uvozovkách. Anglické otevírací uvozovky se v~\LaTeX{}u zadávají jako dva zpětné apostrofy, uzavírací uvozovky jako dva apostrofy. Často chybně uváděný symbol "{} (palce) nemá s~uvozovkami nic společného.
% 
% Dále je třeba zabránit zalomení řádky mezi některými slovy, v~češtině např. za jednopísmennými předložkami a spojkami (vyjma \uv{a}). To docílíte vložením pružné nezalomitelné mezery -- znakem \texttt{\textasciitilde}. V~tomto případě to není třeba dělat ručně, lze použít program \verb|vlna|.
% 
% Více o~typografii viz \cite{kobltypo}.
% 
% \subsection{Obrázky}
% 
% Pro umožnění vkládání obrázků je vhodné použít balíček \verb|graphicx|, samotné vložení se provede příkazem \verb|\includegraphics|. Takto je možné vkládat obrázky ve formátu PDF, PNG a JPEG jestliže používáte pdf\LaTeX{} nebo ve formátu EPS jestliže používáte \LaTeX{}. Doporučujeme preferovat vektorové obrázky před rastrovými (vyjma fotografií).
% 
% \subsubsection{Získání vhodného formátu}
% 
% Pro získání vektorových formátů PDF nebo EPS z~jiných lze použít některý z~vektorových grafických editorů. Pro převod rastrového obrázku na vektorový lze použít rasterizaci, kterou mnohé editory zvládají (např. Inkscape). Pro konverze lze použít též nástroje pro dávkové zpracování běžně dodávané s~\LaTeX{}em, např. \verb|epstopdf|.
% 
% \subsubsection{Plovoucí prostředí}
% 
% Příkazem \verb|\includegraphics| lze obrázky vkládat přímo, doporučujeme však použít plovoucí prostředí, konkrétně \verb|figure|. Například obrázek \ref{fig:float} byl vložen tímto způsobem. Vůbec přitom nevadí, když je obrázek umístěn jinde, než bylo původně zamýšleno -- je tomu tak hlavně kvůli dodržení typografických konvencí. Namísto vynucování konkrétní pozice obrázku doporučujeme používat odkazování z~textu (dvojice příkazů \verb|\label| a \verb|\ref|).
% 
% \begin{figure}\centering
% 	\includegraphics[width=0.5\textwidth, angle=30]{cvut-logo-bw}
% 	\caption[Příklad obrázku]{Ukázkový obrázek v~plovoucím prostředí}\label{fig:float}
% \end{figure}
% 
% \subsubsection{Verze obrázků}
% 
% % Gnuplot BW i barevně
% Může se hodit mít více verzí stejného obrázku, např. pro barevný či černobílý tisk a nebo pro prezentaci. S~pomocí některých nástrojů na generování grafiky je to snadné.
% 
% Máte-li například graf vytvořený v programu Gnuplot, můžete jeho černobílou variantu (viz obr. \ref{fig:gnuplot-bw}) vytvořit parametrem \verb|monochrome dashed| příkazu \verb|set term|. Barevnou variantu (viz obr. \ref{fig:gnuplot-col}) vhodnou na prezentace lze vytvořit parametrem \verb|colour solid|.
% 
% \begin{figure}\centering
% 	\includegraphics{gnuplot-bw}
% 	\caption{Černobílá varianta obrázku generovaného programem Gnuplot}\label{fig:gnuplot-bw}
% \end{figure}
% 
% \begin{figure}\centering
% 	\includegraphics{gnuplot-col}
% 	\caption{Barevná varianta obrázku generovaného programem Gnuplot}\label{fig:gnuplot-col}
% \end{figure}
% 
% 
% \subsection{Tabulky}
% 
% Tabulky lze zadávat různě, např. v~prostředí \verb|tabular|, avšak pro jejich vkládání platí to samé, co pro obrázky -- použijte plovoucí prostředí, v~tomto případě \verb|table|. Například tabulka \ref{tab:matematika} byla vložena tímto způsobem.
% 
% \begin{table}\centering
% 	\caption[Příklad tabulky]{Zadávání matematiky}\label{tab:matematika}
% 	\begin{tabular}{|l|l|c|c|}\hline
% 		Typ		& Prostředí		& \LaTeX{}ovská zkratka	& \TeX{}ovská zkratka	\tabularnewline \hline \hline
% 		Text		& \verb|math|		& \verb|\(...\)|	& \verb|$...$|		\tabularnewline \hline
% 		Displayed	& \verb|displaymath|	& \verb|\[...\]|	& \verb|$$...$$|	\tabularnewline \hline
% 	\end{tabular}
% \end{table}
% 
% % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\chapter{Obsah přiloženého CD}

%upravte podle skutecnosti

\begin{figure}
	\dirtree{%
		.1 readme.txt\DTcomment{stručný popis obsahu CD}.
		.1 exe\DTcomment{adresář se spustitelnou formou implementace}.
		.1 src.
		.2 impl\DTcomment{zdrojové kódy implementace}.
		.2 thesis\DTcomment{zdrojová forma práce ve formátu \LaTeX{}}.
		.1 text\DTcomment{text práce}.
		.2 thesis.pdf\DTcomment{text práce ve formátu PDF}.
		.2 thesis.ps\DTcomment{text práce ve formátu PS}.
	}
\end{figure}

\end{document}
